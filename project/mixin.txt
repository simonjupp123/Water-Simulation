// expansion at /Library/D/dmd/src/druntime/import/core/internal/atomic.d(502,13)

                asm pure nothrow @nogc @trusted
                {
                    mov DL, value;
                    mov AL, compare;

                    mov RCX, dest;
                    lock; cmpxchg [RCX], DL;

                    setz success;
                }


// expansion at /Library/D/dmd/src/druntime/import/core/internal/atomic.d(502,13)

                asm pure nothrow @nogc @trusted
                {
                    mov DX, value;
                    mov AX, compare;

                    mov RCX, dest;
                    lock; cmpxchg [RCX], DX;

                    setz success;
                }


// expansion at /Library/D/dmd/src/druntime/import/core/internal/atomic.d(502,13)

                asm pure nothrow @nogc @trusted
                {
                    mov RDX, value;
                    mov RAX, compare;

                    mov RCX, dest;
                    lock; cmpxchg [RCX], RDX;

                    setz success;
                }


// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/bindbc/sdl/codegen.d(13,1)
alias joinFnBinds = bindbc.common.codegen.joinFnBinds!false;
alias FnBind = bindbc.common.codegen.FnBind;

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/assert_.d(36,1)
private nothrow @nogc{
	alias _pSDL_SetAssertionHandler = extern(C) void function(SDL_AssertionHandler handler, void* userData);
	alias _pSDL_GetAssertionReport = extern(C) const(SDL_assert_data)* function();
	alias _pSDL_ResetAssertionReport = extern(C) void function();
}
__gshared nothrow @nogc{
	package _pSDL_SetAssertionHandler _SDL_SetAssertionHandler;
	extern(C) void SDL_SetAssertionHandler(SDL_AssertionHandler handler, void* userData){ _SDL_SetAssertionHandler(__traits(parameters)); }
	package _pSDL_GetAssertionReport _SDL_GetAssertionReport;
	extern(C) const(SDL_assert_data)* SDL_GetAssertionReport(){ return _SDL_GetAssertionReport(__traits(parameters)); }
	package _pSDL_ResetAssertionReport _SDL_ResetAssertionReport;
	extern(C) void SDL_ResetAssertionReport(){ _SDL_ResetAssertionReport(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_SetAssertionHandler, here.SDL_SetAssertionHandler.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetAssertionReport, here.SDL_GetAssertionReport.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ResetAssertionReport, here.SDL_ResetAssertionReport.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/stdinc.d(133,1)
private nothrow @nogc{
	alias _pSDL_malloc = extern(C) void* function(size_t size);
	alias _pSDL_calloc = extern(C) void* function(size_t nMemB, size_t size);
	alias _pSDL_realloc = extern(C) void* function(void* mem, size_t size);
	alias _pSDL_free = extern(C) void function(void* mem);
	alias _pSDL_getenv = extern(C) char* function(const(char)* name);
	alias _pSDL_setenv = extern(C) int function(const(char)* name, const(char)* value, int overwrite);
	alias _pSDL_qsort = extern(C) void function(void* base, size_t nMemB, size_t size, int function(const(void)*, const(void)*) compare);
	alias _pSDL_abs = extern(C) int function(int x);
	alias _pSDL_isdigit = extern(C) int function(int x);
	alias _pSDL_isspace = extern(C) int function(int x);
	alias _pSDL_toupper = extern(C) int function(int x);
	alias _pSDL_tolower = extern(C) int function(int x);
	alias _pSDL_memset = extern(C) void* function(void* dst, int c, size_t len);
	alias _pSDL_memcpy = extern(C) void* function(void* dst, const(void)* src, size_t len);
	alias _pSDL_memmove = extern(C) void* function(void* dst, const(void)* src, size_t len);
	alias _pSDL_memcmp = extern(C) int function(const(void)* s1, const(void)* s2, size_t len);
	alias _pSDL_wcslen = extern(C) size_t function(const(wchar_t)* wStr);
	alias _pSDL_wcslcpy = extern(C) size_t function(wchar_t* dst, const(wchar_t)* src, size_t maxLen);
	alias _pSDL_wcslcat = extern(C) size_t function(wchar_t* dst, const(wchar_t)* src, size_t maxLen);
	alias _pSDL_strlen = extern(C) size_t function(const(char)* str);
	alias _pSDL_strlcpy = extern(C) size_t function(char* dst, const(char)* src, size_t maxLen);
	alias _pSDL_utf8strlcpy = extern(C) size_t function(char* dst, const(char)* src, size_t dstBytes);
	alias _pSDL_strlcat = extern(C) size_t function(char* dst, const(char)* src, size_t maxLen);
	alias _pSDL_strdup = extern(C) char* function(const(char)* str);
	alias _pSDL_strrev = extern(C) char* function(char* str);
	alias _pSDL_strupr = extern(C) char* function(char* str);
	alias _pSDL_strlwr = extern(C) char* function(char* str);
	alias _pSDL_strchr = extern(C) char* function(const(char)* str, int c);
	alias _pSDL_strrchr = extern(C) char* function(const(char)* str, int c);
	alias _pSDL_strstr = extern(C) char* function(const(char)* haystack, const(char)* needle);
	alias _pSDL_itoa = extern(C) char* function(int value, char* str, int radix);
	alias _pSDL_uitoa = extern(C) char* function(uint value, char* str, int radix);
	alias _pSDL_ltoa = extern(C) char* function(long value, char* str, int radix);
	alias _pSDL_ultoa = extern(C) char* function(ulong value, char* str, int radix);
	alias _pSDL_lltoa = extern(C) char* function(long value, char* str, int radix);
	alias _pSDL_ulltoa = extern(C) char* function(ulong value, char* str, int radix);
	alias _pSDL_atoi = extern(C) int function(const(char)* str);
	alias _pSDL_atof = extern(C) double function(const(char)* str);
	alias _pSDL_strtol = extern(C) long function(const(char)* str, char** endP, int base);
	alias _pSDL_strtoul = extern(C) ulong function(const(char)* str, char** endP, int base);
	alias _pSDL_strtoll = extern(C) long function(const(char)* str, char** endP, int base);
	alias _pSDL_strtoull = extern(C) ulong function(const(char)* str, char** endP, int base);
	alias _pSDL_strtod = extern(C) double function(const(char)* str, char** endP);
	alias _pSDL_strcmp = extern(C) int function(const(char)* str1, const(char)* str2);
	alias _pSDL_strncmp = extern(C) int function(const(char)* str1, const(char)* str2, size_t maxLen);
	alias _pSDL_strcasecmp = extern(C) int function(const(char)* str1, const(char)* str2);
	alias _pSDL_strncasecmp = extern(C) int function(const(char)* str1, const(char)* str2, size_t len);
	alias _pSDL_sscanf = extern(C) int function(const(char)* text, const(char)* fmt, ...);
	alias _pSDL_snprintf = extern(C) int function(char* text, size_t maxLen, const(char)* fmt, ...);
	alias _pSDL_vsnprintf = extern(C) int function(char* text, size_t maxLen, const(char)* fmt, va_list ap);
	alias _pSDL_atan = extern(C) double function(double x);
	alias _pSDL_atan2 = extern(C) double function(double y, double x);
	alias _pSDL_ceil = extern(C) double function(double x);
	alias _pSDL_copysign = extern(C) double function(double x, double y);
	alias _pSDL_cos = extern(C) double function(double x);
	alias _pSDL_cosf = extern(C) float function(float x);
	alias _pSDL_fabs = extern(C) double function(double x);
	alias _pSDL_floor = extern(C) double function(double x);
	alias _pSDL_log = extern(C) double function(double x);
	alias _pSDL_pow = extern(C) double function(double x, double y);
	alias _pSDL_scalbn = extern(C) double function(double x, int n);
	alias _pSDL_sin = extern(C) double function(double x);
	alias _pSDL_sinf = extern(C) float function(float x);
	alias _pSDL_sqrt = extern(C) double function(double x);
	alias _pSDL_iconv_open = extern(C) SDL_iconv_t* function(const(char)* toCode, const(char)* fromCode);
	alias _pSDL_iconv_close = extern(C) int function(SDL_iconv_t* cd);
	alias _pSDL_iconv = extern(C) size_t function(SDL_iconv_t* cd, const(char)** inBuf, size_t* inBytesLeft, char** outBuf, size_t* outBytesLeft);
	alias _pSDL_iconv_string = extern(C) char* function(const(char)* toCode, const(char)* fromCode, const(char)* inBuf, size_t inBytesLeft);
}
__gshared nothrow @nogc{
	package _pSDL_malloc _SDL_malloc;
	extern(C) void* SDL_malloc(size_t size){ return _SDL_malloc(__traits(parameters)); }
	package _pSDL_calloc _SDL_calloc;
	extern(C) void* SDL_calloc(size_t nMemB, size_t size){ return _SDL_calloc(__traits(parameters)); }
	package _pSDL_realloc _SDL_realloc;
	extern(C) void* SDL_realloc(void* mem, size_t size){ return _SDL_realloc(__traits(parameters)); }
	package _pSDL_free _SDL_free;
	extern(C) void SDL_free(void* mem){ _SDL_free(__traits(parameters)); }
	package _pSDL_getenv _SDL_getenv;
	extern(C) char* SDL_getenv(const(char)* name){ return _SDL_getenv(__traits(parameters)); }
	package _pSDL_setenv _SDL_setenv;
	extern(C) int SDL_setenv(const(char)* name, const(char)* value, int overwrite){ return _SDL_setenv(__traits(parameters)); }
	package _pSDL_qsort _SDL_qsort;
	extern(C) void SDL_qsort(void* base, size_t nMemB, size_t size, int function(const(void)*, const(void)*) compare){ _SDL_qsort(__traits(parameters)); }
	package _pSDL_abs _SDL_abs;
	extern(C) int SDL_abs(int x){ return _SDL_abs(__traits(parameters)); }
	package _pSDL_isdigit _SDL_isdigit;
	extern(C) int SDL_isdigit(int x){ return _SDL_isdigit(__traits(parameters)); }
	package _pSDL_isspace _SDL_isspace;
	extern(C) int SDL_isspace(int x){ return _SDL_isspace(__traits(parameters)); }
	package _pSDL_toupper _SDL_toupper;
	extern(C) int SDL_toupper(int x){ return _SDL_toupper(__traits(parameters)); }
	package _pSDL_tolower _SDL_tolower;
	extern(C) int SDL_tolower(int x){ return _SDL_tolower(__traits(parameters)); }
	package _pSDL_memset _SDL_memset;
	extern(C) void* SDL_memset(void* dst, int c, size_t len){ return _SDL_memset(__traits(parameters)); }
	package _pSDL_memcpy _SDL_memcpy;
	extern(C) void* SDL_memcpy(void* dst, const(void)* src, size_t len){ return _SDL_memcpy(__traits(parameters)); }
	package _pSDL_memmove _SDL_memmove;
	extern(C) void* SDL_memmove(void* dst, const(void)* src, size_t len){ return _SDL_memmove(__traits(parameters)); }
	package _pSDL_memcmp _SDL_memcmp;
	extern(C) int SDL_memcmp(const(void)* s1, const(void)* s2, size_t len){ return _SDL_memcmp(__traits(parameters)); }
	package _pSDL_wcslen _SDL_wcslen;
	extern(C) size_t SDL_wcslen(const(wchar_t)* wStr){ return _SDL_wcslen(__traits(parameters)); }
	package _pSDL_wcslcpy _SDL_wcslcpy;
	extern(C) size_t SDL_wcslcpy(wchar_t* dst, const(wchar_t)* src, size_t maxLen){ return _SDL_wcslcpy(__traits(parameters)); }
	package _pSDL_wcslcat _SDL_wcslcat;
	extern(C) size_t SDL_wcslcat(wchar_t* dst, const(wchar_t)* src, size_t maxLen){ return _SDL_wcslcat(__traits(parameters)); }
	package _pSDL_strlen _SDL_strlen;
	extern(C) size_t SDL_strlen(const(char)* str){ return _SDL_strlen(__traits(parameters)); }
	package _pSDL_strlcpy _SDL_strlcpy;
	extern(C) size_t SDL_strlcpy(char* dst, const(char)* src, size_t maxLen){ return _SDL_strlcpy(__traits(parameters)); }
	package _pSDL_utf8strlcpy _SDL_utf8strlcpy;
	extern(C) size_t SDL_utf8strlcpy(char* dst, const(char)* src, size_t dstBytes){ return _SDL_utf8strlcpy(__traits(parameters)); }
	package _pSDL_strlcat _SDL_strlcat;
	extern(C) size_t SDL_strlcat(char* dst, const(char)* src, size_t maxLen){ return _SDL_strlcat(__traits(parameters)); }
	package _pSDL_strdup _SDL_strdup;
	extern(C) char* SDL_strdup(const(char)* str){ return _SDL_strdup(__traits(parameters)); }
	package _pSDL_strrev _SDL_strrev;
	extern(C) char* SDL_strrev(char* str){ return _SDL_strrev(__traits(parameters)); }
	package _pSDL_strupr _SDL_strupr;
	extern(C) char* SDL_strupr(char* str){ return _SDL_strupr(__traits(parameters)); }
	package _pSDL_strlwr _SDL_strlwr;
	extern(C) char* SDL_strlwr(char* str){ return _SDL_strlwr(__traits(parameters)); }
	package _pSDL_strchr _SDL_strchr;
	extern(C) char* SDL_strchr(const(char)* str, int c){ return _SDL_strchr(__traits(parameters)); }
	package _pSDL_strrchr _SDL_strrchr;
	extern(C) char* SDL_strrchr(const(char)* str, int c){ return _SDL_strrchr(__traits(parameters)); }
	package _pSDL_strstr _SDL_strstr;
	extern(C) char* SDL_strstr(const(char)* haystack, const(char)* needle){ return _SDL_strstr(__traits(parameters)); }
	package _pSDL_itoa _SDL_itoa;
	extern(C) char* SDL_itoa(int value, char* str, int radix){ return _SDL_itoa(__traits(parameters)); }
	package _pSDL_uitoa _SDL_uitoa;
	extern(C) char* SDL_uitoa(uint value, char* str, int radix){ return _SDL_uitoa(__traits(parameters)); }
	package _pSDL_ltoa _SDL_ltoa;
	extern(C) char* SDL_ltoa(long value, char* str, int radix){ return _SDL_ltoa(__traits(parameters)); }
	package _pSDL_ultoa _SDL_ultoa;
	extern(C) char* SDL_ultoa(ulong value, char* str, int radix){ return _SDL_ultoa(__traits(parameters)); }
	package _pSDL_lltoa _SDL_lltoa;
	extern(C) char* SDL_lltoa(long value, char* str, int radix){ return _SDL_lltoa(__traits(parameters)); }
	package _pSDL_ulltoa _SDL_ulltoa;
	extern(C) char* SDL_ulltoa(ulong value, char* str, int radix){ return _SDL_ulltoa(__traits(parameters)); }
	package _pSDL_atoi _SDL_atoi;
	extern(C) int SDL_atoi(const(char)* str){ return _SDL_atoi(__traits(parameters)); }
	package _pSDL_atof _SDL_atof;
	extern(C) double SDL_atof(const(char)* str){ return _SDL_atof(__traits(parameters)); }
	package _pSDL_strtol _SDL_strtol;
	extern(C) long SDL_strtol(const(char)* str, char** endP, int base){ return _SDL_strtol(__traits(parameters)); }
	package _pSDL_strtoul _SDL_strtoul;
	extern(C) ulong SDL_strtoul(const(char)* str, char** endP, int base){ return _SDL_strtoul(__traits(parameters)); }
	package _pSDL_strtoll _SDL_strtoll;
	extern(C) long SDL_strtoll(const(char)* str, char** endP, int base){ return _SDL_strtoll(__traits(parameters)); }
	package _pSDL_strtoull _SDL_strtoull;
	extern(C) ulong SDL_strtoull(const(char)* str, char** endP, int base){ return _SDL_strtoull(__traits(parameters)); }
	package _pSDL_strtod _SDL_strtod;
	extern(C) double SDL_strtod(const(char)* str, char** endP){ return _SDL_strtod(__traits(parameters)); }
	package _pSDL_strcmp _SDL_strcmp;
	extern(C) int SDL_strcmp(const(char)* str1, const(char)* str2){ return _SDL_strcmp(__traits(parameters)); }
	package _pSDL_strncmp _SDL_strncmp;
	extern(C) int SDL_strncmp(const(char)* str1, const(char)* str2, size_t maxLen){ return _SDL_strncmp(__traits(parameters)); }
	package _pSDL_strcasecmp _SDL_strcasecmp;
	extern(C) int SDL_strcasecmp(const(char)* str1, const(char)* str2){ return _SDL_strcasecmp(__traits(parameters)); }
	package _pSDL_strncasecmp _SDL_strncasecmp;
	extern(C) int SDL_strncasecmp(const(char)* str1, const(char)* str2, size_t len){ return _SDL_strncasecmp(__traits(parameters)); }
	_pSDL_sscanf SDL_sscanf;
	_pSDL_snprintf SDL_snprintf;
	package _pSDL_vsnprintf _SDL_vsnprintf;
	extern(C) int SDL_vsnprintf(char* text, size_t maxLen, const(char)* fmt, va_list ap){ return _SDL_vsnprintf(__traits(parameters)); }
	package _pSDL_atan _SDL_atan;
	extern(C) double SDL_atan(double x){ return _SDL_atan(__traits(parameters)); }
	package _pSDL_atan2 _SDL_atan2;
	extern(C) double SDL_atan2(double y, double x){ return _SDL_atan2(__traits(parameters)); }
	package _pSDL_ceil _SDL_ceil;
	extern(C) double SDL_ceil(double x){ return _SDL_ceil(__traits(parameters)); }
	package _pSDL_copysign _SDL_copysign;
	extern(C) double SDL_copysign(double x, double y){ return _SDL_copysign(__traits(parameters)); }
	package _pSDL_cos _SDL_cos;
	extern(C) double SDL_cos(double x){ return _SDL_cos(__traits(parameters)); }
	package _pSDL_cosf _SDL_cosf;
	extern(C) float SDL_cosf(float x){ return _SDL_cosf(__traits(parameters)); }
	package _pSDL_fabs _SDL_fabs;
	extern(C) double SDL_fabs(double x){ return _SDL_fabs(__traits(parameters)); }
	package _pSDL_floor _SDL_floor;
	extern(C) double SDL_floor(double x){ return _SDL_floor(__traits(parameters)); }
	package _pSDL_log _SDL_log;
	extern(C) double SDL_log(double x){ return _SDL_log(__traits(parameters)); }
	package _pSDL_pow _SDL_pow;
	extern(C) double SDL_pow(double x, double y){ return _SDL_pow(__traits(parameters)); }
	package _pSDL_scalbn _SDL_scalbn;
	extern(C) double SDL_scalbn(double x, int n){ return _SDL_scalbn(__traits(parameters)); }
	package _pSDL_sin _SDL_sin;
	extern(C) double SDL_sin(double x){ return _SDL_sin(__traits(parameters)); }
	package _pSDL_sinf _SDL_sinf;
	extern(C) float SDL_sinf(float x){ return _SDL_sinf(__traits(parameters)); }
	package _pSDL_sqrt _SDL_sqrt;
	extern(C) double SDL_sqrt(double x){ return _SDL_sqrt(__traits(parameters)); }
	package _pSDL_iconv_open _SDL_iconv_open;
	extern(C) SDL_iconv_t* SDL_iconv_open(const(char)* toCode, const(char)* fromCode){ return _SDL_iconv_open(__traits(parameters)); }
	package _pSDL_iconv_close _SDL_iconv_close;
	extern(C) int SDL_iconv_close(SDL_iconv_t* cd){ return _SDL_iconv_close(__traits(parameters)); }
	package _pSDL_iconv _SDL_iconv;
	extern(C) size_t SDL_iconv(SDL_iconv_t* cd, const(char)** inBuf, size_t* inBytesLeft, char** outBuf, size_t* outBytesLeft){ return _SDL_iconv(__traits(parameters)); }
	package _pSDL_iconv_string _SDL_iconv_string;
	extern(C) char* SDL_iconv_string(const(char)* toCode, const(char)* fromCode, const(char)* inBuf, size_t inBytesLeft){ return _SDL_iconv_string(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_malloc, here.SDL_malloc.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_calloc, here.SDL_calloc.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_realloc, here.SDL_realloc.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_free, here.SDL_free.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_getenv, here.SDL_getenv.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_setenv, here.SDL_setenv.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_qsort, here.SDL_qsort.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_abs, here.SDL_abs.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_isdigit, here.SDL_isdigit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_isspace, here.SDL_isspace.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_toupper, here.SDL_toupper.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_tolower, here.SDL_tolower.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_memset, here.SDL_memset.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_memcpy, here.SDL_memcpy.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_memmove, here.SDL_memmove.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_memcmp, here.SDL_memcmp.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_wcslen, here.SDL_wcslen.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_wcslcpy, here.SDL_wcslcpy.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_wcslcat, here.SDL_wcslcat.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strlen, here.SDL_strlen.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strlcpy, here.SDL_strlcpy.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_utf8strlcpy, here.SDL_utf8strlcpy.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strlcat, here.SDL_strlcat.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strdup, here.SDL_strdup.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strrev, here.SDL_strrev.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strupr, here.SDL_strupr.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strlwr, here.SDL_strlwr.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strchr, here.SDL_strchr.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strrchr, here.SDL_strrchr.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strstr, here.SDL_strstr.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_itoa, here.SDL_itoa.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_uitoa, here.SDL_uitoa.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ltoa, here.SDL_ltoa.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ultoa, here.SDL_ultoa.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_lltoa, here.SDL_lltoa.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ulltoa, here.SDL_ulltoa.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_atoi, here.SDL_atoi.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_atof, here.SDL_atof.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strtol, here.SDL_strtol.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strtoul, here.SDL_strtoul.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strtoll, here.SDL_strtoll.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strtoull, here.SDL_strtoull.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strtod, here.SDL_strtod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strcmp, here.SDL_strcmp.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strncmp, here.SDL_strncmp.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strcasecmp, here.SDL_strcasecmp.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_strncasecmp, here.SDL_strncasecmp.mangleof);
	lib.bindSymbol(cast(void**)&SDL_sscanf, "SDL_sscanf");
	lib.bindSymbol(cast(void**)&SDL_snprintf, "SDL_snprintf");
	lib.bindSymbol(cast(void**)&_SDL_vsnprintf, here.SDL_vsnprintf.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_atan, here.SDL_atan.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_atan2, here.SDL_atan2.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ceil, here.SDL_ceil.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_copysign, here.SDL_copysign.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_cos, here.SDL_cos.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_cosf, here.SDL_cosf.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_fabs, here.SDL_fabs.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_floor, here.SDL_floor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_log, here.SDL_log.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_pow, here.SDL_pow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_scalbn, here.SDL_scalbn.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_sin, here.SDL_sin.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_sinf, here.SDL_sinf.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_sqrt, here.SDL_sqrt.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_iconv_open, here.SDL_iconv_open.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_iconv_close, here.SDL_iconv_close.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_iconv, here.SDL_iconv.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_iconv_string, here.SDL_iconv_string.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/atomic.d(154,1)
private nothrow @nogc{
	alias _pSDL_AtomicTryLock = extern(C) SDL_bool function(SDL_SpinLock* lock);
	alias _pSDL_AtomicLock = extern(C) void function(SDL_SpinLock* lock);
	alias _pSDL_AtomicUnlock = extern(C) void function(SDL_SpinLock* lock);
	alias _pSDL_AtomicCAS = extern(C) SDL_bool function(SDL_atomic_t* a, int oldVal, int newVal);
	alias _pSDL_AtomicCASPtr = extern(C) SDL_bool function(void** a, void* oldVal, void* newVal);
}
__gshared nothrow @nogc{
	package _pSDL_AtomicTryLock _SDL_AtomicTryLock;
	extern(C) SDL_bool SDL_AtomicTryLock(SDL_SpinLock* lock){ return _SDL_AtomicTryLock(__traits(parameters)); }
	package _pSDL_AtomicLock _SDL_AtomicLock;
	extern(C) void SDL_AtomicLock(SDL_SpinLock* lock){ _SDL_AtomicLock(__traits(parameters)); }
	package _pSDL_AtomicUnlock _SDL_AtomicUnlock;
	extern(C) void SDL_AtomicUnlock(SDL_SpinLock* lock){ _SDL_AtomicUnlock(__traits(parameters)); }
	package _pSDL_AtomicCAS _SDL_AtomicCAS;
	extern(C) SDL_bool SDL_AtomicCAS(SDL_atomic_t* a, int oldVal, int newVal){ return _SDL_AtomicCAS(__traits(parameters)); }
	package _pSDL_AtomicCASPtr _SDL_AtomicCASPtr;
	extern(C) SDL_bool SDL_AtomicCASPtr(void** a, void* oldVal, void* newVal){ return _SDL_AtomicCASPtr(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_AtomicTryLock, here.SDL_AtomicTryLock.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AtomicLock, here.SDL_AtomicLock.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AtomicUnlock, here.SDL_AtomicUnlock.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AtomicCAS, here.SDL_AtomicCAS.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AtomicCASPtr, here.SDL_AtomicCASPtr.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/rwops.d(106,1)
private nothrow @nogc{
	alias _pSDL_RWFromFile = extern(C) SDL_RWops* function(const(char)* file, const(char)* mode);
	alias _pSDL_RWFromMem = extern(C) SDL_RWops* function(void* mem, int size);
	alias _pSDL_RWFromConstMem = extern(C) SDL_RWops* function(const(void)* mem, int size);
	alias _pSDL_AllocRW = extern(C) SDL_RWops* function();
	alias _pSDL_FreeRW = extern(C) void function(SDL_RWops* context);
	alias _pSDL_ReadU8 = extern(C) ubyte function(SDL_RWops* context);
	alias _pSDL_ReadLE16 = extern(C) ushort function(SDL_RWops* context);
	alias _pSDL_ReadBE16 = extern(C) ushort function(SDL_RWops* context);
	alias _pSDL_ReadLE32 = extern(C) uint function(SDL_RWops* context);
	alias _pSDL_ReadBE32 = extern(C) uint function(SDL_RWops* context);
	alias _pSDL_ReadLE64 = extern(C) ulong function(SDL_RWops* context);
	alias _pSDL_ReadBE64 = extern(C) ulong function(SDL_RWops* context);
	alias _pSDL_WriteU8 = extern(C) size_t function(SDL_RWops* context, ubyte value);
	alias _pSDL_WriteLE16 = extern(C) size_t function(SDL_RWops* context, ushort value);
	alias _pSDL_WriteBE16 = extern(C) size_t function(SDL_RWops* context, ushort value);
	alias _pSDL_WriteLE32 = extern(C) size_t function(SDL_RWops* context, uint value);
	alias _pSDL_WriteBE32 = extern(C) size_t function(SDL_RWops* context, uint value);
	alias _pSDL_WriteLE64 = extern(C) size_t function(SDL_RWops* context, ulong value);
	alias _pSDL_WriteBE64 = extern(C) size_t function(SDL_RWops* context, ulong value);
	alias _pSDL_RWFromFP = extern(C) SDL_RWops* function(FILE* ffp, SDL_bool autoClose);
}
__gshared nothrow @nogc{
	package _pSDL_RWFromFile _SDL_RWFromFile;
	extern(C) SDL_RWops* SDL_RWFromFile(const(char)* file, const(char)* mode){ return _SDL_RWFromFile(__traits(parameters)); }
	package _pSDL_RWFromMem _SDL_RWFromMem;
	extern(C) SDL_RWops* SDL_RWFromMem(void* mem, int size){ return _SDL_RWFromMem(__traits(parameters)); }
	package _pSDL_RWFromConstMem _SDL_RWFromConstMem;
	extern(C) SDL_RWops* SDL_RWFromConstMem(const(void)* mem, int size){ return _SDL_RWFromConstMem(__traits(parameters)); }
	package _pSDL_AllocRW _SDL_AllocRW;
	extern(C) SDL_RWops* SDL_AllocRW(){ return _SDL_AllocRW(__traits(parameters)); }
	package _pSDL_FreeRW _SDL_FreeRW;
	extern(C) void SDL_FreeRW(SDL_RWops* context){ _SDL_FreeRW(__traits(parameters)); }
	package _pSDL_ReadU8 _SDL_ReadU8;
	extern(C) ubyte SDL_ReadU8(SDL_RWops* context){ return _SDL_ReadU8(__traits(parameters)); }
	package _pSDL_ReadLE16 _SDL_ReadLE16;
	extern(C) ushort SDL_ReadLE16(SDL_RWops* context){ return _SDL_ReadLE16(__traits(parameters)); }
	package _pSDL_ReadBE16 _SDL_ReadBE16;
	extern(C) ushort SDL_ReadBE16(SDL_RWops* context){ return _SDL_ReadBE16(__traits(parameters)); }
	package _pSDL_ReadLE32 _SDL_ReadLE32;
	extern(C) uint SDL_ReadLE32(SDL_RWops* context){ return _SDL_ReadLE32(__traits(parameters)); }
	package _pSDL_ReadBE32 _SDL_ReadBE32;
	extern(C) uint SDL_ReadBE32(SDL_RWops* context){ return _SDL_ReadBE32(__traits(parameters)); }
	package _pSDL_ReadLE64 _SDL_ReadLE64;
	extern(C) ulong SDL_ReadLE64(SDL_RWops* context){ return _SDL_ReadLE64(__traits(parameters)); }
	package _pSDL_ReadBE64 _SDL_ReadBE64;
	extern(C) ulong SDL_ReadBE64(SDL_RWops* context){ return _SDL_ReadBE64(__traits(parameters)); }
	package _pSDL_WriteU8 _SDL_WriteU8;
	extern(C) size_t SDL_WriteU8(SDL_RWops* context, ubyte value){ return _SDL_WriteU8(__traits(parameters)); }
	package _pSDL_WriteLE16 _SDL_WriteLE16;
	extern(C) size_t SDL_WriteLE16(SDL_RWops* context, ushort value){ return _SDL_WriteLE16(__traits(parameters)); }
	package _pSDL_WriteBE16 _SDL_WriteBE16;
	extern(C) size_t SDL_WriteBE16(SDL_RWops* context, ushort value){ return _SDL_WriteBE16(__traits(parameters)); }
	package _pSDL_WriteLE32 _SDL_WriteLE32;
	extern(C) size_t SDL_WriteLE32(SDL_RWops* context, uint value){ return _SDL_WriteLE32(__traits(parameters)); }
	package _pSDL_WriteBE32 _SDL_WriteBE32;
	extern(C) size_t SDL_WriteBE32(SDL_RWops* context, uint value){ return _SDL_WriteBE32(__traits(parameters)); }
	package _pSDL_WriteLE64 _SDL_WriteLE64;
	extern(C) size_t SDL_WriteLE64(SDL_RWops* context, ulong value){ return _SDL_WriteLE64(__traits(parameters)); }
	package _pSDL_WriteBE64 _SDL_WriteBE64;
	extern(C) size_t SDL_WriteBE64(SDL_RWops* context, ulong value){ return _SDL_WriteBE64(__traits(parameters)); }
	package _pSDL_RWFromFP _SDL_RWFromFP;
	extern(C) SDL_RWops* SDL_RWFromFP(FILE* ffp, SDL_bool autoClose){ return _SDL_RWFromFP(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_RWFromFile, here.SDL_RWFromFile.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RWFromMem, here.SDL_RWFromMem.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RWFromConstMem, here.SDL_RWFromConstMem.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AllocRW, here.SDL_AllocRW.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FreeRW, here.SDL_FreeRW.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ReadU8, here.SDL_ReadU8.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ReadLE16, here.SDL_ReadLE16.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ReadBE16, here.SDL_ReadBE16.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ReadLE32, here.SDL_ReadLE32.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ReadBE32, here.SDL_ReadBE32.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ReadLE64, here.SDL_ReadLE64.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ReadBE64, here.SDL_ReadBE64.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WriteU8, here.SDL_WriteU8.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WriteLE16, here.SDL_WriteLE16.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WriteBE16, here.SDL_WriteBE16.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WriteLE32, here.SDL_WriteLE32.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WriteBE32, here.SDL_WriteBE32.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WriteLE64, here.SDL_WriteLE64.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WriteBE64, here.SDL_WriteBE64.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RWFromFP, here.SDL_RWFromFP.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/audio.d(142,1)
private nothrow @nogc{
	alias _pSDL_GetNumAudioDrivers = extern(C) int function();
	alias _pSDL_GetAudioDriver = extern(C) const(char)* function(int index);
	alias _pSDL_AudioInit = extern(C) int function(const(char)* driverName);
	alias _pSDL_AudioQuit = extern(C) void function();
	alias _pSDL_GetCurrentAudioDriver = extern(C) const(char)* function();
	alias _pSDL_OpenAudio = extern(C) int function(SDL_AudioSpec* desired, SDL_AudioSpec* obtained);
	alias _pSDL_GetNumAudioDevices = extern(C) int function(int isCapture);
	alias _pSDL_GetAudioDeviceName = extern(C) const(char)* function(int index, int isCapture);
	alias _pSDL_OpenAudioDevice = extern(C) SDL_AudioDeviceID function(const(char)* device, int isCapture, const(SDL_AudioSpec)* desired, SDL_AudioSpec* obtained, int allowedChanges);
	alias _pSDL_GetAudioStatus = extern(C) SDL_AudioStatus function();
	alias _pSDL_GetAudioDeviceStatus = extern(C) SDL_AudioStatus function(SDL_AudioDeviceID dev);
	alias _pSDL_PauseAudio = extern(C) void function(int pauseOn);
	alias _pSDL_PauseAudioDevice = extern(C) void function(SDL_AudioDeviceID dev, int pauseOn);
	alias _pSDL_LoadWAV_RW = extern(C) SDL_AudioSpec* function(SDL_RWops* src, int freeSrc, SDL_AudioSpec* spec, ubyte** audioBuf, uint* audioLen);
	alias _pSDL_FreeWAV = extern(C) void function(ubyte* audioBuf);
	alias _pSDL_BuildAudioCVT = extern(C) int function(SDL_AudioCVT* cvt, SDL_AudioFormat srcFormat, ubyte srcChannels, int srcRate, SDL_AudioFormat dstFormat, ubyte dstChannels, int dstRate);
	alias _pSDL_ConvertAudio = extern(C) int function(SDL_AudioCVT* cvt);
	alias _pSDL_MixAudio = extern(C) void function(ubyte* dst, const(ubyte)* src, uint len, int volume);
	alias _pSDL_MixAudioFormat = extern(C) void function(ubyte* dst, const(ubyte)* src, SDL_AudioFormat format, uint len, int volume);
	alias _pSDL_LockAudio = extern(C) void function();
	alias _pSDL_LockAudioDevice = extern(C) void function(SDL_AudioDeviceID dev);
	alias _pSDL_UnlockAudio = extern(C) void function();
	alias _pSDL_UnlockAudioDevice = extern(C) void function(SDL_AudioDeviceID dev);
	alias _pSDL_CloseAudio = extern(C) void function();
	alias _pSDL_CloseAudioDevice = extern(C) void function(SDL_AudioDeviceID dev);
}
__gshared nothrow @nogc{
	package _pSDL_GetNumAudioDrivers _SDL_GetNumAudioDrivers;
	extern(C) int SDL_GetNumAudioDrivers(){ return _SDL_GetNumAudioDrivers(__traits(parameters)); }
	package _pSDL_GetAudioDriver _SDL_GetAudioDriver;
	extern(C) const(char)* SDL_GetAudioDriver(int index){ return _SDL_GetAudioDriver(__traits(parameters)); }
	package _pSDL_AudioInit _SDL_AudioInit;
	extern(C) int SDL_AudioInit(const(char)* driverName){ return _SDL_AudioInit(__traits(parameters)); }
	package _pSDL_AudioQuit _SDL_AudioQuit;
	extern(C) void SDL_AudioQuit(){ _SDL_AudioQuit(__traits(parameters)); }
	package _pSDL_GetCurrentAudioDriver _SDL_GetCurrentAudioDriver;
	extern(C) const(char)* SDL_GetCurrentAudioDriver(){ return _SDL_GetCurrentAudioDriver(__traits(parameters)); }
	package _pSDL_OpenAudio _SDL_OpenAudio;
	extern(C) int SDL_OpenAudio(SDL_AudioSpec* desired, SDL_AudioSpec* obtained){ return _SDL_OpenAudio(__traits(parameters)); }
	package _pSDL_GetNumAudioDevices _SDL_GetNumAudioDevices;
	extern(C) int SDL_GetNumAudioDevices(int isCapture){ return _SDL_GetNumAudioDevices(__traits(parameters)); }
	package _pSDL_GetAudioDeviceName _SDL_GetAudioDeviceName;
	extern(C) const(char)* SDL_GetAudioDeviceName(int index, int isCapture){ return _SDL_GetAudioDeviceName(__traits(parameters)); }
	package _pSDL_OpenAudioDevice _SDL_OpenAudioDevice;
	extern(C) SDL_AudioDeviceID SDL_OpenAudioDevice(const(char)* device, int isCapture, const(SDL_AudioSpec)* desired, SDL_AudioSpec* obtained, int allowedChanges){ return _SDL_OpenAudioDevice(__traits(parameters)); }
	package _pSDL_GetAudioStatus _SDL_GetAudioStatus;
	extern(C) SDL_AudioStatus SDL_GetAudioStatus(){ return _SDL_GetAudioStatus(__traits(parameters)); }
	package _pSDL_GetAudioDeviceStatus _SDL_GetAudioDeviceStatus;
	extern(C) SDL_AudioStatus SDL_GetAudioDeviceStatus(SDL_AudioDeviceID dev){ return _SDL_GetAudioDeviceStatus(__traits(parameters)); }
	package _pSDL_PauseAudio _SDL_PauseAudio;
	extern(C) void SDL_PauseAudio(int pauseOn){ _SDL_PauseAudio(__traits(parameters)); }
	package _pSDL_PauseAudioDevice _SDL_PauseAudioDevice;
	extern(C) void SDL_PauseAudioDevice(SDL_AudioDeviceID dev, int pauseOn){ _SDL_PauseAudioDevice(__traits(parameters)); }
	package _pSDL_LoadWAV_RW _SDL_LoadWAV_RW;
	extern(C) SDL_AudioSpec* SDL_LoadWAV_RW(SDL_RWops* src, int freeSrc, SDL_AudioSpec* spec, ubyte** audioBuf, uint* audioLen){ return _SDL_LoadWAV_RW(__traits(parameters)); }
	package _pSDL_FreeWAV _SDL_FreeWAV;
	extern(C) void SDL_FreeWAV(ubyte* audioBuf){ _SDL_FreeWAV(__traits(parameters)); }
	package _pSDL_BuildAudioCVT _SDL_BuildAudioCVT;
	extern(C) int SDL_BuildAudioCVT(SDL_AudioCVT* cvt, SDL_AudioFormat srcFormat, ubyte srcChannels, int srcRate, SDL_AudioFormat dstFormat, ubyte dstChannels, int dstRate){ return _SDL_BuildAudioCVT(__traits(parameters)); }
	package _pSDL_ConvertAudio _SDL_ConvertAudio;
	extern(C) int SDL_ConvertAudio(SDL_AudioCVT* cvt){ return _SDL_ConvertAudio(__traits(parameters)); }
	package _pSDL_MixAudio _SDL_MixAudio;
	extern(C) void SDL_MixAudio(ubyte* dst, const(ubyte)* src, uint len, int volume){ _SDL_MixAudio(__traits(parameters)); }
	package _pSDL_MixAudioFormat _SDL_MixAudioFormat;
	extern(C) void SDL_MixAudioFormat(ubyte* dst, const(ubyte)* src, SDL_AudioFormat format, uint len, int volume){ _SDL_MixAudioFormat(__traits(parameters)); }
	package _pSDL_LockAudio _SDL_LockAudio;
	extern(C) void SDL_LockAudio(){ _SDL_LockAudio(__traits(parameters)); }
	package _pSDL_LockAudioDevice _SDL_LockAudioDevice;
	extern(C) void SDL_LockAudioDevice(SDL_AudioDeviceID dev){ _SDL_LockAudioDevice(__traits(parameters)); }
	package _pSDL_UnlockAudio _SDL_UnlockAudio;
	extern(C) void SDL_UnlockAudio(){ _SDL_UnlockAudio(__traits(parameters)); }
	package _pSDL_UnlockAudioDevice _SDL_UnlockAudioDevice;
	extern(C) void SDL_UnlockAudioDevice(SDL_AudioDeviceID dev){ _SDL_UnlockAudioDevice(__traits(parameters)); }
	package _pSDL_CloseAudio _SDL_CloseAudio;
	extern(C) void SDL_CloseAudio(){ _SDL_CloseAudio(__traits(parameters)); }
	package _pSDL_CloseAudioDevice _SDL_CloseAudioDevice;
	extern(C) void SDL_CloseAudioDevice(SDL_AudioDeviceID dev){ _SDL_CloseAudioDevice(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetNumAudioDrivers, here.SDL_GetNumAudioDrivers.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetAudioDriver, here.SDL_GetAudioDriver.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AudioInit, here.SDL_AudioInit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AudioQuit, here.SDL_AudioQuit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetCurrentAudioDriver, here.SDL_GetCurrentAudioDriver.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_OpenAudio, here.SDL_OpenAudio.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetNumAudioDevices, here.SDL_GetNumAudioDevices.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetAudioDeviceName, here.SDL_GetAudioDeviceName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_OpenAudioDevice, here.SDL_OpenAudioDevice.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetAudioStatus, here.SDL_GetAudioStatus.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetAudioDeviceStatus, here.SDL_GetAudioDeviceStatus.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_PauseAudio, here.SDL_PauseAudio.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_PauseAudioDevice, here.SDL_PauseAudioDevice.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LoadWAV_RW, here.SDL_LoadWAV_RW.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FreeWAV, here.SDL_FreeWAV.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_BuildAudioCVT, here.SDL_BuildAudioCVT.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ConvertAudio, here.SDL_ConvertAudio.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_MixAudio, here.SDL_MixAudio.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_MixAudioFormat, here.SDL_MixAudioFormat.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LockAudio, here.SDL_LockAudio.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LockAudioDevice, here.SDL_LockAudioDevice.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UnlockAudio, here.SDL_UnlockAudio.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UnlockAudioDevice, here.SDL_UnlockAudioDevice.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CloseAudio, here.SDL_CloseAudio.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CloseAudioDevice, here.SDL_CloseAudioDevice.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/blendmode.d(59,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/clipboard.d(15,1)
private nothrow @nogc{
	alias _pSDL_SetClipboardText = extern(C) int function(const(char)* text);
	alias _pSDL_GetClipboardText = extern(C) char* function();
	alias _pSDL_HasClipboardText = extern(C) SDL_bool function();
}
__gshared nothrow @nogc{
	package _pSDL_SetClipboardText _SDL_SetClipboardText;
	extern(C) int SDL_SetClipboardText(const(char)* text){ return _SDL_SetClipboardText(__traits(parameters)); }
	package _pSDL_GetClipboardText _SDL_GetClipboardText;
	extern(C) char* SDL_GetClipboardText(){ return _SDL_GetClipboardText(__traits(parameters)); }
	package _pSDL_HasClipboardText _SDL_HasClipboardText;
	extern(C) SDL_bool SDL_HasClipboardText(){ return _SDL_HasClipboardText(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_SetClipboardText, here.SDL_SetClipboardText.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetClipboardText, here.SDL_GetClipboardText.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasClipboardText, here.SDL_HasClipboardText.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/cpuinfo.d(17,1)
private nothrow @nogc{
	alias _pSDL_GetCPUCount = extern(C) int function();
	alias _pSDL_GetCPUCacheLineSize = extern(C) int function();
	alias _pSDL_HasRDTSC = extern(C) SDL_bool function();
	alias _pSDL_HasAltiVec = extern(C) SDL_bool function();
	alias _pSDL_HasMMX = extern(C) SDL_bool function();
	alias _pSDL_Has3DNow = extern(C) SDL_bool function();
	alias _pSDL_HasSSE = extern(C) SDL_bool function();
	alias _pSDL_HasSSE2 = extern(C) SDL_bool function();
	alias _pSDL_HasSSE3 = extern(C) SDL_bool function();
	alias _pSDL_HasSSE41 = extern(C) SDL_bool function();
	alias _pSDL_HasSSE42 = extern(C) SDL_bool function();
}
__gshared nothrow @nogc{
	package _pSDL_GetCPUCount _SDL_GetCPUCount;
	extern(C) int SDL_GetCPUCount(){ return _SDL_GetCPUCount(__traits(parameters)); }
	package _pSDL_GetCPUCacheLineSize _SDL_GetCPUCacheLineSize;
	extern(C) int SDL_GetCPUCacheLineSize(){ return _SDL_GetCPUCacheLineSize(__traits(parameters)); }
	package _pSDL_HasRDTSC _SDL_HasRDTSC;
	extern(C) SDL_bool SDL_HasRDTSC(){ return _SDL_HasRDTSC(__traits(parameters)); }
	package _pSDL_HasAltiVec _SDL_HasAltiVec;
	extern(C) SDL_bool SDL_HasAltiVec(){ return _SDL_HasAltiVec(__traits(parameters)); }
	package _pSDL_HasMMX _SDL_HasMMX;
	extern(C) SDL_bool SDL_HasMMX(){ return _SDL_HasMMX(__traits(parameters)); }
	package _pSDL_Has3DNow _SDL_Has3DNow;
	extern(C) SDL_bool SDL_Has3DNow(){ return _SDL_Has3DNow(__traits(parameters)); }
	package _pSDL_HasSSE _SDL_HasSSE;
	extern(C) SDL_bool SDL_HasSSE(){ return _SDL_HasSSE(__traits(parameters)); }
	package _pSDL_HasSSE2 _SDL_HasSSE2;
	extern(C) SDL_bool SDL_HasSSE2(){ return _SDL_HasSSE2(__traits(parameters)); }
	package _pSDL_HasSSE3 _SDL_HasSSE3;
	extern(C) SDL_bool SDL_HasSSE3(){ return _SDL_HasSSE3(__traits(parameters)); }
	package _pSDL_HasSSE41 _SDL_HasSSE41;
	extern(C) SDL_bool SDL_HasSSE41(){ return _SDL_HasSSE41(__traits(parameters)); }
	package _pSDL_HasSSE42 _SDL_HasSSE42;
	extern(C) SDL_bool SDL_HasSSE42(){ return _SDL_HasSSE42(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetCPUCount, here.SDL_GetCPUCount.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetCPUCacheLineSize, here.SDL_GetCPUCacheLineSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasRDTSC, here.SDL_HasRDTSC.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasAltiVec, here.SDL_HasAltiVec.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasMMX, here.SDL_HasMMX.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_Has3DNow, here.SDL_Has3DNow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasSSE, here.SDL_HasSSE.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasSSE2, here.SDL_HasSSE2.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasSSE3, here.SDL_HasSSE3.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasSSE41, here.SDL_HasSSE41.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasSSE42, here.SDL_HasSSE42.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/error.d(29,1)
private nothrow @nogc{
	alias _pSDL_SetError = extern(C) void function(const(char)* fmt, ...);
	alias _pSDL_GetError = extern(C) const(char)* function();
	alias _pSDL_ClearError = extern(C) void function();
	alias _pSDL_Error = extern(C) int function(SDL_errorcode code);
}
__gshared nothrow @nogc{
	_pSDL_SetError SDL_SetError;
	package _pSDL_GetError _SDL_GetError;
	extern(C) const(char)* SDL_GetError(){ return _SDL_GetError(__traits(parameters)); }
	package _pSDL_ClearError _SDL_ClearError;
	extern(C) void SDL_ClearError(){ _SDL_ClearError(__traits(parameters)); }
	package _pSDL_Error _SDL_Error;
	extern(C) int SDL_Error(SDL_errorcode code){ return _SDL_Error(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&SDL_SetError, "SDL_SetError");
	lib.bindSymbol(cast(void**)&_SDL_GetError, here.SDL_GetError.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ClearError, here.SDL_ClearError.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_Error, here.SDL_Error.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/touch.d(37,1)
private nothrow @nogc{
	alias _pSDL_GetNumTouchDevices = extern(C) int function();
	alias _pSDL_GetTouchDevice = extern(C) SDL_TouchID function(int index);
	alias _pSDL_GetNumTouchFingers = extern(C) int function(SDL_TouchID touchID);
	alias _pSDL_GetTouchFinger = extern(C) SDL_Finger* function(SDL_TouchID touchID, int index);
}
__gshared nothrow @nogc{
	package _pSDL_GetNumTouchDevices _SDL_GetNumTouchDevices;
	extern(C) int SDL_GetNumTouchDevices(){ return _SDL_GetNumTouchDevices(__traits(parameters)); }
	package _pSDL_GetTouchDevice _SDL_GetTouchDevice;
	extern(C) SDL_TouchID SDL_GetTouchDevice(int index){ return _SDL_GetTouchDevice(__traits(parameters)); }
	package _pSDL_GetNumTouchFingers _SDL_GetNumTouchFingers;
	extern(C) int SDL_GetNumTouchFingers(SDL_TouchID touchID){ return _SDL_GetNumTouchFingers(__traits(parameters)); }
	package _pSDL_GetTouchFinger _SDL_GetTouchFinger;
	extern(C) SDL_Finger* SDL_GetTouchFinger(SDL_TouchID touchID, int index){ return _SDL_GetTouchFinger(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetNumTouchDevices, here.SDL_GetNumTouchDevices.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetTouchDevice, here.SDL_GetTouchDevice.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetNumTouchFingers, here.SDL_GetNumTouchFingers.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetTouchFinger, here.SDL_GetTouchFinger.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/gesture.d(18,1)
private nothrow @nogc{
	alias _pSDL_RecordGesture = extern(C) int function(SDL_TouchID touchID);
	alias _pSDL_SaveAllDollarTemplates = extern(C) int function(SDL_RWops* dst);
	alias _pSDL_SaveDollarTemplate = extern(C) int function(SDL_GestureID gestureID, SDL_RWops* dst);
	alias _pSDL_LoadDollarTemplates = extern(C) int function(SDL_TouchID touchID, SDL_RWops* src);
}
__gshared nothrow @nogc{
	package _pSDL_RecordGesture _SDL_RecordGesture;
	extern(C) int SDL_RecordGesture(SDL_TouchID touchID){ return _SDL_RecordGesture(__traits(parameters)); }
	package _pSDL_SaveAllDollarTemplates _SDL_SaveAllDollarTemplates;
	extern(C) int SDL_SaveAllDollarTemplates(SDL_RWops* dst){ return _SDL_SaveAllDollarTemplates(__traits(parameters)); }
	package _pSDL_SaveDollarTemplate _SDL_SaveDollarTemplate;
	extern(C) int SDL_SaveDollarTemplate(SDL_GestureID gestureID, SDL_RWops* dst){ return _SDL_SaveDollarTemplate(__traits(parameters)); }
	package _pSDL_LoadDollarTemplates _SDL_LoadDollarTemplates;
	extern(C) int SDL_LoadDollarTemplates(SDL_TouchID touchID, SDL_RWops* src){ return _SDL_LoadDollarTemplates(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_RecordGesture, here.SDL_RecordGesture.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SaveAllDollarTemplates, here.SDL_SaveAllDollarTemplates.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SaveDollarTemplate, here.SDL_SaveDollarTemplate.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LoadDollarTemplates, here.SDL_LoadDollarTemplates.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/guid.d(16,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/joystick.d(103,1)
private nothrow @nogc{
	alias _pSDL_NumJoysticks = extern(C) int function();
	alias _pSDL_JoystickNameForIndex = extern(C) const(char)* function(int deviceIndex);
	alias _pSDL_JoystickGetDeviceGUID = extern(C) SDL_JoystickGUID function(int deviceIndex);
	alias _pSDL_JoystickOpen = extern(C) SDL_Joystick* function(int device_index);
	alias _pSDL_JoystickName = extern(C) const(char)* function(SDL_Joystick* joystick);
	alias _pSDL_JoystickGetGUID = extern(C) SDL_JoystickGUID function(SDL_Joystick* joystick);
	alias _pSDL_JoystickGetGUIDString = extern(C) void function(SDL_JoystickGUID guid, char* pszGUID, int cbGUID);
	alias _pSDL_JoystickGetGUIDFromString = extern(C) SDL_JoystickGUID function(const(char)*);
	alias _pSDL_JoystickGetAttached = extern(C) SDL_bool function(SDL_Joystick* joystick);
	alias _pSDL_JoystickInstanceID = extern(C) SDL_JoystickID function(SDL_Joystick* joystick);
	alias _pSDL_JoystickNumAxes = extern(C) int function(SDL_Joystick* joystick);
	alias _pSDL_JoystickNumBalls = extern(C) int function(SDL_Joystick* joystick);
	alias _pSDL_JoystickNumHats = extern(C) int function(SDL_Joystick* joystick);
	alias _pSDL_JoystickNumButtons = extern(C) int function(SDL_Joystick* joystick);
	alias _pSDL_JoystickUpdate = extern(C) void function();
	alias _pSDL_JoystickEventState = extern(C) int function(int state);
	alias _pSDL_JoystickGetAxis = extern(C) short function(SDL_Joystick* joystick, int axis);
	alias _pSDL_JoystickGetHat = extern(C) ubyte function(SDL_Joystick* joystick, int hat);
	alias _pSDL_JoystickGetBall = extern(C) int function(SDL_Joystick* joystick, int ball, int* dx, int* dy);
	alias _pSDL_JoystickGetButton = extern(C) ubyte function(SDL_Joystick* joystick, int button);
	alias _pSDL_JoystickClose = extern(C) void function(SDL_Joystick* joystick);
}
__gshared nothrow @nogc{
	package _pSDL_NumJoysticks _SDL_NumJoysticks;
	extern(C) int SDL_NumJoysticks(){ return _SDL_NumJoysticks(__traits(parameters)); }
	package _pSDL_JoystickNameForIndex _SDL_JoystickNameForIndex;
	extern(C) const(char)* SDL_JoystickNameForIndex(int deviceIndex){ return _SDL_JoystickNameForIndex(__traits(parameters)); }
	package _pSDL_JoystickGetDeviceGUID _SDL_JoystickGetDeviceGUID;
	extern(C) SDL_JoystickGUID SDL_JoystickGetDeviceGUID(int deviceIndex){ return _SDL_JoystickGetDeviceGUID(__traits(parameters)); }
	package _pSDL_JoystickOpen _SDL_JoystickOpen;
	extern(C) SDL_Joystick* SDL_JoystickOpen(int device_index){ return _SDL_JoystickOpen(__traits(parameters)); }
	package _pSDL_JoystickName _SDL_JoystickName;
	extern(C) const(char)* SDL_JoystickName(SDL_Joystick* joystick){ return _SDL_JoystickName(__traits(parameters)); }
	package _pSDL_JoystickGetGUID _SDL_JoystickGetGUID;
	extern(C) SDL_JoystickGUID SDL_JoystickGetGUID(SDL_Joystick* joystick){ return _SDL_JoystickGetGUID(__traits(parameters)); }
	package _pSDL_JoystickGetGUIDString _SDL_JoystickGetGUIDString;
	extern(C) void SDL_JoystickGetGUIDString(SDL_JoystickGUID guid, char* pszGUID, int cbGUID){ _SDL_JoystickGetGUIDString(__traits(parameters)); }
	package _pSDL_JoystickGetGUIDFromString _SDL_JoystickGetGUIDFromString;
	extern(C) SDL_JoystickGUID SDL_JoystickGetGUIDFromString(const(char)*){ return _SDL_JoystickGetGUIDFromString(__traits(parameters)); }
	package _pSDL_JoystickGetAttached _SDL_JoystickGetAttached;
	extern(C) SDL_bool SDL_JoystickGetAttached(SDL_Joystick* joystick){ return _SDL_JoystickGetAttached(__traits(parameters)); }
	package _pSDL_JoystickInstanceID _SDL_JoystickInstanceID;
	extern(C) SDL_JoystickID SDL_JoystickInstanceID(SDL_Joystick* joystick){ return _SDL_JoystickInstanceID(__traits(parameters)); }
	package _pSDL_JoystickNumAxes _SDL_JoystickNumAxes;
	extern(C) int SDL_JoystickNumAxes(SDL_Joystick* joystick){ return _SDL_JoystickNumAxes(__traits(parameters)); }
	package _pSDL_JoystickNumBalls _SDL_JoystickNumBalls;
	extern(C) int SDL_JoystickNumBalls(SDL_Joystick* joystick){ return _SDL_JoystickNumBalls(__traits(parameters)); }
	package _pSDL_JoystickNumHats _SDL_JoystickNumHats;
	extern(C) int SDL_JoystickNumHats(SDL_Joystick* joystick){ return _SDL_JoystickNumHats(__traits(parameters)); }
	package _pSDL_JoystickNumButtons _SDL_JoystickNumButtons;
	extern(C) int SDL_JoystickNumButtons(SDL_Joystick* joystick){ return _SDL_JoystickNumButtons(__traits(parameters)); }
	package _pSDL_JoystickUpdate _SDL_JoystickUpdate;
	extern(C) void SDL_JoystickUpdate(){ _SDL_JoystickUpdate(__traits(parameters)); }
	package _pSDL_JoystickEventState _SDL_JoystickEventState;
	extern(C) int SDL_JoystickEventState(int state){ return _SDL_JoystickEventState(__traits(parameters)); }
	package _pSDL_JoystickGetAxis _SDL_JoystickGetAxis;
	extern(C) short SDL_JoystickGetAxis(SDL_Joystick* joystick, int axis){ return _SDL_JoystickGetAxis(__traits(parameters)); }
	package _pSDL_JoystickGetHat _SDL_JoystickGetHat;
	extern(C) ubyte SDL_JoystickGetHat(SDL_Joystick* joystick, int hat){ return _SDL_JoystickGetHat(__traits(parameters)); }
	package _pSDL_JoystickGetBall _SDL_JoystickGetBall;
	extern(C) int SDL_JoystickGetBall(SDL_Joystick* joystick, int ball, int* dx, int* dy){ return _SDL_JoystickGetBall(__traits(parameters)); }
	package _pSDL_JoystickGetButton _SDL_JoystickGetButton;
	extern(C) ubyte SDL_JoystickGetButton(SDL_Joystick* joystick, int button){ return _SDL_JoystickGetButton(__traits(parameters)); }
	package _pSDL_JoystickClose _SDL_JoystickClose;
	extern(C) void SDL_JoystickClose(SDL_Joystick* joystick){ _SDL_JoystickClose(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_NumJoysticks, here.SDL_NumJoysticks.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickNameForIndex, here.SDL_JoystickNameForIndex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetDeviceGUID, here.SDL_JoystickGetDeviceGUID.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickOpen, here.SDL_JoystickOpen.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickName, here.SDL_JoystickName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetGUID, here.SDL_JoystickGetGUID.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetGUIDString, here.SDL_JoystickGetGUIDString.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetGUIDFromString, here.SDL_JoystickGetGUIDFromString.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetAttached, here.SDL_JoystickGetAttached.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickInstanceID, here.SDL_JoystickInstanceID.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickNumAxes, here.SDL_JoystickNumAxes.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickNumBalls, here.SDL_JoystickNumBalls.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickNumHats, here.SDL_JoystickNumHats.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickNumButtons, here.SDL_JoystickNumButtons.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickUpdate, here.SDL_JoystickUpdate.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickEventState, here.SDL_JoystickEventState.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetAxis, here.SDL_JoystickGetAxis.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetHat, here.SDL_JoystickGetHat.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetBall, here.SDL_JoystickGetBall.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickGetButton, here.SDL_JoystickGetButton.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickClose, here.SDL_JoystickClose.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/rect.d(74,1)
private nothrow @nogc{
	alias _pSDL_HasIntersection = extern(C) SDL_bool function(const(SDL_Rect)* a, const(SDL_Rect)* b);
	alias _pSDL_IntersectRect = extern(C) SDL_bool function(const(SDL_Rect)* a, const(SDL_Rect)* b,SDL_Rect* result);
	alias _pSDL_UnionRect = extern(C) void function(const(SDL_Rect)* a, const(SDL_Rect)* b, SDL_Rect* result);
	alias _pSDL_EnclosePoints = extern(C) SDL_bool function(const(SDL_Point)* points, int count, const(SDL_Rect)* clip, SDL_Rect* result);
	alias _pSDL_IntersectRectAndLine = extern(C) SDL_bool function(const(SDL_Rect)* rect, int* x1, int* y1, int* x2, int* y2);
}
__gshared nothrow @nogc{
	package _pSDL_HasIntersection _SDL_HasIntersection;
	extern(C) SDL_bool SDL_HasIntersection(const(SDL_Rect)* a, const(SDL_Rect)* b){ return _SDL_HasIntersection(__traits(parameters)); }
	package _pSDL_IntersectRect _SDL_IntersectRect;
	extern(C) SDL_bool SDL_IntersectRect(const(SDL_Rect)* a, const(SDL_Rect)* b,SDL_Rect* result){ return _SDL_IntersectRect(__traits(parameters)); }
	package _pSDL_UnionRect _SDL_UnionRect;
	extern(C) void SDL_UnionRect(const(SDL_Rect)* a, const(SDL_Rect)* b, SDL_Rect* result){ _SDL_UnionRect(__traits(parameters)); }
	package _pSDL_EnclosePoints _SDL_EnclosePoints;
	extern(C) SDL_bool SDL_EnclosePoints(const(SDL_Point)* points, int count, const(SDL_Rect)* clip, SDL_Rect* result){ return _SDL_EnclosePoints(__traits(parameters)); }
	package _pSDL_IntersectRectAndLine _SDL_IntersectRectAndLine;
	extern(C) SDL_bool SDL_IntersectRectAndLine(const(SDL_Rect)* rect, int* x1, int* y1, int* x2, int* y2){ return _SDL_IntersectRectAndLine(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_HasIntersection, here.SDL_HasIntersection.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_IntersectRect, here.SDL_IntersectRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UnionRect, here.SDL_UnionRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_EnclosePoints, here.SDL_EnclosePoints.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_IntersectRectAndLine, here.SDL_IntersectRectAndLine.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/pixels.d(361,1)
private nothrow @nogc{
	alias _pSDL_GetPixelFormatName = extern(C) const(char)* function(SDL_PixelFormatEnum format);
	alias _pSDL_PixelFormatEnumToMasks = extern(C) SDL_bool function(SDL_PixelFormatEnum format, int* bpp, uint* rMask, uint* gMask, uint* bMask, uint* aMask);
	alias _pSDL_MasksToPixelFormatEnum = extern(C) uint function(int bpp, uint rMask, uint gMask, uint bMask, uint aMask);
	alias _pSDL_AllocFormat = extern(C) SDL_PixelFormat* function(uint pixelFormat);
	alias _pSDL_FreeFormat = extern(C) void function(SDL_PixelFormat* format);
	alias _pSDL_AllocPalette = extern(C) SDL_Palette* function(int nColours);
	alias _pSDL_SetPixelFormatPalette = extern(C) int function(SDL_PixelFormat* format, SDL_Palette* palette);
	alias _pSDL_SetPaletteColors = extern(C) int function(SDL_Palette* palette, const(SDL_Color)* colours, int firstColour, int nColours);
	alias _pSDL_FreePalette = extern(C) void function(SDL_Palette* palette);
	alias _pSDL_MapRGB = extern(C) uint function(const(SDL_PixelFormat)* format, ubyte r, ubyte g, ubyte b);
	alias _pSDL_MapRGBA = extern(C) uint function(const(SDL_PixelFormat)* format, ubyte r, ubyte g, ubyte b, ubyte a);
	alias _pSDL_GetRGB = extern(C) void function(uint pixel, const(SDL_PixelFormat)* format, ubyte* r, ubyte* g, ubyte* b);
	alias _pSDL_GetRGBA = extern(C) void function(uint pixel, const(SDL_PixelFormat)* format, ubyte* r, ubyte* g, ubyte* b, ubyte* a);
	alias _pSDL_CalculateGammaRamp = extern(C) void function(float gamma, ushort* ramp);
}
__gshared nothrow @nogc{
	package _pSDL_GetPixelFormatName _SDL_GetPixelFormatName;
	extern(C) const(char)* SDL_GetPixelFormatName(SDL_PixelFormatEnum format){ return _SDL_GetPixelFormatName(__traits(parameters)); }
	package _pSDL_PixelFormatEnumToMasks _SDL_PixelFormatEnumToMasks;
	extern(C) SDL_bool SDL_PixelFormatEnumToMasks(SDL_PixelFormatEnum format, int* bpp, uint* rMask, uint* gMask, uint* bMask, uint* aMask){ return _SDL_PixelFormatEnumToMasks(__traits(parameters)); }
	package _pSDL_MasksToPixelFormatEnum _SDL_MasksToPixelFormatEnum;
	extern(C) uint SDL_MasksToPixelFormatEnum(int bpp, uint rMask, uint gMask, uint bMask, uint aMask){ return _SDL_MasksToPixelFormatEnum(__traits(parameters)); }
	package _pSDL_AllocFormat _SDL_AllocFormat;
	extern(C) SDL_PixelFormat* SDL_AllocFormat(uint pixelFormat){ return _SDL_AllocFormat(__traits(parameters)); }
	package _pSDL_FreeFormat _SDL_FreeFormat;
	extern(C) void SDL_FreeFormat(SDL_PixelFormat* format){ _SDL_FreeFormat(__traits(parameters)); }
	package _pSDL_AllocPalette _SDL_AllocPalette;
	extern(C) SDL_Palette* SDL_AllocPalette(int nColours){ return _SDL_AllocPalette(__traits(parameters)); }
	package _pSDL_SetPixelFormatPalette _SDL_SetPixelFormatPalette;
	extern(C) int SDL_SetPixelFormatPalette(SDL_PixelFormat* format, SDL_Palette* palette){ return _SDL_SetPixelFormatPalette(__traits(parameters)); }
	package _pSDL_SetPaletteColors _SDL_SetPaletteColors;
	extern(C) int SDL_SetPaletteColors(SDL_Palette* palette, const(SDL_Color)* colours, int firstColour, int nColours){ return _SDL_SetPaletteColors(__traits(parameters)); }
	package _pSDL_FreePalette _SDL_FreePalette;
	extern(C) void SDL_FreePalette(SDL_Palette* palette){ _SDL_FreePalette(__traits(parameters)); }
	package _pSDL_MapRGB _SDL_MapRGB;
	extern(C) uint SDL_MapRGB(const(SDL_PixelFormat)* format, ubyte r, ubyte g, ubyte b){ return _SDL_MapRGB(__traits(parameters)); }
	package _pSDL_MapRGBA _SDL_MapRGBA;
	extern(C) uint SDL_MapRGBA(const(SDL_PixelFormat)* format, ubyte r, ubyte g, ubyte b, ubyte a){ return _SDL_MapRGBA(__traits(parameters)); }
	package _pSDL_GetRGB _SDL_GetRGB;
	extern(C) void SDL_GetRGB(uint pixel, const(SDL_PixelFormat)* format, ubyte* r, ubyte* g, ubyte* b){ _SDL_GetRGB(__traits(parameters)); }
	package _pSDL_GetRGBA _SDL_GetRGBA;
	extern(C) void SDL_GetRGBA(uint pixel, const(SDL_PixelFormat)* format, ubyte* r, ubyte* g, ubyte* b, ubyte* a){ _SDL_GetRGBA(__traits(parameters)); }
	package _pSDL_CalculateGammaRamp _SDL_CalculateGammaRamp;
	extern(C) void SDL_CalculateGammaRamp(float gamma, ushort* ramp){ _SDL_CalculateGammaRamp(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetPixelFormatName, here.SDL_GetPixelFormatName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_PixelFormatEnumToMasks, here.SDL_PixelFormatEnumToMasks.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_MasksToPixelFormatEnum, here.SDL_MasksToPixelFormatEnum.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AllocFormat, here.SDL_AllocFormat.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FreeFormat, here.SDL_FreeFormat.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AllocPalette, here.SDL_AllocPalette.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetPixelFormatPalette, here.SDL_SetPixelFormatPalette.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetPaletteColors, here.SDL_SetPaletteColors.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FreePalette, here.SDL_FreePalette.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_MapRGB, here.SDL_MapRGB.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_MapRGBA, here.SDL_MapRGBA.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRGB, here.SDL_GetRGB.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRGBA, here.SDL_GetRGBA.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CalculateGammaRamp, here.SDL_CalculateGammaRamp.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/surface.d(78,1)
private nothrow @nogc{
	alias _pSDL_CreateRGBSurface = extern(C) SDL_Surface* function(uint flags, int width, int height, int depth, uint rMask, uint gMask, uint bMask, uint aMask);
	alias _pSDL_CreateRGBSurfaceFrom = extern(C) SDL_Surface* function(void* pixels, int width, int height, int depth, int pitch, uint rMask, uint gMask, uint bMask, uint aMask);
	alias _pSDL_FreeSurface = extern(C) void function(SDL_Surface* surface);
	alias _pSDL_SetSurfacePalette = extern(C) int function(SDL_Surface* surface, SDL_Palette* palette);
	alias _pSDL_LockSurface = extern(C) int function(SDL_Surface* surface);
	alias _pSDL_UnlockSurface = extern(C) int function(SDL_Surface* surface);
	alias _pSDL_LoadBMP_RW = extern(C) SDL_Surface* function(SDL_RWops* src, int freeSrc);
	alias _pSDL_SaveBMP_RW = extern(C) int function(SDL_Surface* surface, SDL_RWops* dst, int freeDst);
	alias _pSDL_SetSurfaceRLE = extern(C) int function(SDL_Surface* surface, int flag);
	alias _pSDL_SetColorKey = extern(C) int function(SDL_Surface* surface, int flag, uint key);
	alias _pSDL_GetColorKey = extern(C) int function(SDL_Surface* surface, uint* key);
	alias _pSDL_SetSurfaceColorMod = extern(C) int function(SDL_Surface* surface, ubyte r, ubyte g, ubyte b);
	alias _pSDL_GetSurfaceColorMod = extern(C) int function(SDL_Surface* surface, ubyte* r, ubyte* g, ubyte* b);
	alias _pSDL_SetSurfaceAlphaMod = extern(C) int function(SDL_Surface* surface, ubyte alpha);
	alias _pSDL_GetSurfaceAlphaMod = extern(C) int function(SDL_Surface* surface, ubyte* alpha);
	alias _pSDL_SetSurfaceBlendMode = extern(C) int function(SDL_Surface* surface, SDL_BlendMode blendMode);
	alias _pSDL_GetSurfaceBlendMode = extern(C) int function(SDL_Surface* surface, SDL_BlendMode* blendMode);
	alias _pSDL_SetClipRect = extern(C) SDL_bool function(SDL_Surface* surface, const(SDL_Rect)* rect);
	alias _pSDL_GetClipRect = extern(C) void function(SDL_Surface* surface, SDL_Rect* rect);
	alias _pSDL_ConvertSurface = extern(C) SDL_Surface* function(SDL_Surface* surface, const(SDL_PixelFormat)* fmt, uint flags);
	alias _pSDL_ConvertSurfaceFormat = extern(C) SDL_Surface* function(SDL_Surface* surface, uint pixelFormat, uint flags);
	alias _pSDL_ConvertPixels = extern(C) int function(int width, int height, uint srcFormat, const(void)* src, int srcPitch, uint dstFormat, void* dst, int dstPitch);
	alias _pSDL_FillRect = extern(C) int function(SDL_Surface* surface, const(SDL_Rect)* rect, uint colour);
	alias _pSDL_FillRects = extern(C) int function(SDL_Surface* surface, const(SDL_Rect)* rects, int count, uint colour);
	alias _pSDL_UpperBlit = extern(C) int function(SDL_Surface* src, const(SDL_Rect)* srcrect, SDL_Surface* dst, SDL_Rect* dstRect);
	alias _pSDL_LowerBlit = extern(C) int function(SDL_Surface* src, SDL_Rect* srcRect, SDL_Surface* dst, SDL_Rect* dstRect);
	alias _pSDL_SoftStretch = extern(C) int function(SDL_Surface* src, const(SDL_Rect)* srcRect, SDL_Surface* dst, const(SDL_Rect)* dstRect);
	alias _pSDL_UpperBlitScaled = extern(C) int function(SDL_Surface* src, const(SDL_Rect)* srcRect, SDL_Surface* dst, SDL_Rect* dstRect);
	alias _pSDL_LowerBlitScaled = extern(C) int function(SDL_Surface* src, SDL_Rect* srcRect, SDL_Surface* dst, SDL_Rect* dstRect);
}
__gshared nothrow @nogc{
	package _pSDL_CreateRGBSurface _SDL_CreateRGBSurface;
	extern(C) SDL_Surface* SDL_CreateRGBSurface(uint flags, int width, int height, int depth, uint rMask, uint gMask, uint bMask, uint aMask){ return _SDL_CreateRGBSurface(__traits(parameters)); }
	package _pSDL_CreateRGBSurfaceFrom _SDL_CreateRGBSurfaceFrom;
	extern(C) SDL_Surface* SDL_CreateRGBSurfaceFrom(void* pixels, int width, int height, int depth, int pitch, uint rMask, uint gMask, uint bMask, uint aMask){ return _SDL_CreateRGBSurfaceFrom(__traits(parameters)); }
	package _pSDL_FreeSurface _SDL_FreeSurface;
	extern(C) void SDL_FreeSurface(SDL_Surface* surface){ _SDL_FreeSurface(__traits(parameters)); }
	package _pSDL_SetSurfacePalette _SDL_SetSurfacePalette;
	extern(C) int SDL_SetSurfacePalette(SDL_Surface* surface, SDL_Palette* palette){ return _SDL_SetSurfacePalette(__traits(parameters)); }
	package _pSDL_LockSurface _SDL_LockSurface;
	extern(C) int SDL_LockSurface(SDL_Surface* surface){ return _SDL_LockSurface(__traits(parameters)); }
	package _pSDL_UnlockSurface _SDL_UnlockSurface;
	extern(C) int SDL_UnlockSurface(SDL_Surface* surface){ return _SDL_UnlockSurface(__traits(parameters)); }
	package _pSDL_LoadBMP_RW _SDL_LoadBMP_RW;
	extern(C) SDL_Surface* SDL_LoadBMP_RW(SDL_RWops* src, int freeSrc){ return _SDL_LoadBMP_RW(__traits(parameters)); }
	package _pSDL_SaveBMP_RW _SDL_SaveBMP_RW;
	extern(C) int SDL_SaveBMP_RW(SDL_Surface* surface, SDL_RWops* dst, int freeDst){ return _SDL_SaveBMP_RW(__traits(parameters)); }
	package _pSDL_SetSurfaceRLE _SDL_SetSurfaceRLE;
	extern(C) int SDL_SetSurfaceRLE(SDL_Surface* surface, int flag){ return _SDL_SetSurfaceRLE(__traits(parameters)); }
	package _pSDL_SetColorKey _SDL_SetColorKey;
	extern(C) int SDL_SetColorKey(SDL_Surface* surface, int flag, uint key){ return _SDL_SetColorKey(__traits(parameters)); }
	package _pSDL_GetColorKey _SDL_GetColorKey;
	extern(C) int SDL_GetColorKey(SDL_Surface* surface, uint* key){ return _SDL_GetColorKey(__traits(parameters)); }
	package _pSDL_SetSurfaceColorMod _SDL_SetSurfaceColorMod;
	extern(C) int SDL_SetSurfaceColorMod(SDL_Surface* surface, ubyte r, ubyte g, ubyte b){ return _SDL_SetSurfaceColorMod(__traits(parameters)); }
	package _pSDL_GetSurfaceColorMod _SDL_GetSurfaceColorMod;
	extern(C) int SDL_GetSurfaceColorMod(SDL_Surface* surface, ubyte* r, ubyte* g, ubyte* b){ return _SDL_GetSurfaceColorMod(__traits(parameters)); }
	package _pSDL_SetSurfaceAlphaMod _SDL_SetSurfaceAlphaMod;
	extern(C) int SDL_SetSurfaceAlphaMod(SDL_Surface* surface, ubyte alpha){ return _SDL_SetSurfaceAlphaMod(__traits(parameters)); }
	package _pSDL_GetSurfaceAlphaMod _SDL_GetSurfaceAlphaMod;
	extern(C) int SDL_GetSurfaceAlphaMod(SDL_Surface* surface, ubyte* alpha){ return _SDL_GetSurfaceAlphaMod(__traits(parameters)); }
	package _pSDL_SetSurfaceBlendMode _SDL_SetSurfaceBlendMode;
	extern(C) int SDL_SetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode blendMode){ return _SDL_SetSurfaceBlendMode(__traits(parameters)); }
	package _pSDL_GetSurfaceBlendMode _SDL_GetSurfaceBlendMode;
	extern(C) int SDL_GetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode* blendMode){ return _SDL_GetSurfaceBlendMode(__traits(parameters)); }
	package _pSDL_SetClipRect _SDL_SetClipRect;
	extern(C) SDL_bool SDL_SetClipRect(SDL_Surface* surface, const(SDL_Rect)* rect){ return _SDL_SetClipRect(__traits(parameters)); }
	package _pSDL_GetClipRect _SDL_GetClipRect;
	extern(C) void SDL_GetClipRect(SDL_Surface* surface, SDL_Rect* rect){ _SDL_GetClipRect(__traits(parameters)); }
	package _pSDL_ConvertSurface _SDL_ConvertSurface;
	extern(C) SDL_Surface* SDL_ConvertSurface(SDL_Surface* surface, const(SDL_PixelFormat)* fmt, uint flags){ return _SDL_ConvertSurface(__traits(parameters)); }
	package _pSDL_ConvertSurfaceFormat _SDL_ConvertSurfaceFormat;
	extern(C) SDL_Surface* SDL_ConvertSurfaceFormat(SDL_Surface* surface, uint pixelFormat, uint flags){ return _SDL_ConvertSurfaceFormat(__traits(parameters)); }
	package _pSDL_ConvertPixels _SDL_ConvertPixels;
	extern(C) int SDL_ConvertPixels(int width, int height, uint srcFormat, const(void)* src, int srcPitch, uint dstFormat, void* dst, int dstPitch){ return _SDL_ConvertPixels(__traits(parameters)); }
	package _pSDL_FillRect _SDL_FillRect;
	extern(C) int SDL_FillRect(SDL_Surface* surface, const(SDL_Rect)* rect, uint colour){ return _SDL_FillRect(__traits(parameters)); }
	package _pSDL_FillRects _SDL_FillRects;
	extern(C) int SDL_FillRects(SDL_Surface* surface, const(SDL_Rect)* rects, int count, uint colour){ return _SDL_FillRects(__traits(parameters)); }
	package _pSDL_UpperBlit _SDL_UpperBlit;
	extern(C) int SDL_UpperBlit(SDL_Surface* src, const(SDL_Rect)* srcrect, SDL_Surface* dst, SDL_Rect* dstRect){ return _SDL_UpperBlit(__traits(parameters)); }
	package _pSDL_LowerBlit _SDL_LowerBlit;
	extern(C) int SDL_LowerBlit(SDL_Surface* src, SDL_Rect* srcRect, SDL_Surface* dst, SDL_Rect* dstRect){ return _SDL_LowerBlit(__traits(parameters)); }
	package _pSDL_SoftStretch _SDL_SoftStretch;
	extern(C) int SDL_SoftStretch(SDL_Surface* src, const(SDL_Rect)* srcRect, SDL_Surface* dst, const(SDL_Rect)* dstRect){ return _SDL_SoftStretch(__traits(parameters)); }
	package _pSDL_UpperBlitScaled _SDL_UpperBlitScaled;
	extern(C) int SDL_UpperBlitScaled(SDL_Surface* src, const(SDL_Rect)* srcRect, SDL_Surface* dst, SDL_Rect* dstRect){ return _SDL_UpperBlitScaled(__traits(parameters)); }
	package _pSDL_LowerBlitScaled _SDL_LowerBlitScaled;
	extern(C) int SDL_LowerBlitScaled(SDL_Surface* src, SDL_Rect* srcRect, SDL_Surface* dst, SDL_Rect* dstRect){ return _SDL_LowerBlitScaled(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_CreateRGBSurface, here.SDL_CreateRGBSurface.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateRGBSurfaceFrom, here.SDL_CreateRGBSurfaceFrom.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FreeSurface, here.SDL_FreeSurface.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetSurfacePalette, here.SDL_SetSurfacePalette.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LockSurface, here.SDL_LockSurface.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UnlockSurface, here.SDL_UnlockSurface.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LoadBMP_RW, here.SDL_LoadBMP_RW.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SaveBMP_RW, here.SDL_SaveBMP_RW.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetSurfaceRLE, here.SDL_SetSurfaceRLE.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetColorKey, here.SDL_SetColorKey.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetColorKey, here.SDL_GetColorKey.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetSurfaceColorMod, here.SDL_SetSurfaceColorMod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetSurfaceColorMod, here.SDL_GetSurfaceColorMod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetSurfaceAlphaMod, here.SDL_SetSurfaceAlphaMod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetSurfaceAlphaMod, here.SDL_GetSurfaceAlphaMod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetSurfaceBlendMode, here.SDL_SetSurfaceBlendMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetSurfaceBlendMode, here.SDL_GetSurfaceBlendMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetClipRect, here.SDL_SetClipRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetClipRect, here.SDL_GetClipRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ConvertSurface, here.SDL_ConvertSurface.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ConvertSurfaceFormat, here.SDL_ConvertSurfaceFormat.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ConvertPixels, here.SDL_ConvertPixels.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FillRect, here.SDL_FillRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FillRects, here.SDL_FillRects.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UpperBlit, here.SDL_UpperBlit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LowerBlit, here.SDL_LowerBlit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SoftStretch, here.SDL_SoftStretch.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UpperBlitScaled, here.SDL_UpperBlitScaled.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LowerBlitScaled, here.SDL_LowerBlitScaled.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/video.d(250,1)
private nothrow @nogc{
	alias _pSDL_GetNumVideoDrivers = extern(C) int function();
	alias _pSDL_GetVideoDriver = extern(C) const(char)* function(int index);
	alias _pSDL_VideoInit = extern(C) int function(const(char)* driverName);
	alias _pSDL_VideoQuit = extern(C) void function();
	alias _pSDL_GetCurrentVideoDriver = extern(C) const(char)* function();
	alias _pSDL_GetNumVideoDisplays = extern(C) int function();
	alias _pSDL_GetDisplayName = extern(C) const(char)* function(int displayIndex);
	alias _pSDL_GetDisplayBounds = extern(C) int function(int displayIndex, SDL_Rect* rect);
	alias _pSDL_GetNumDisplayModes = extern(C) int function(int displayIndex);
	alias _pSDL_GetDisplayMode = extern(C) int function(int displayIndex, int modeIndex, SDL_DisplayMode* mode);
	alias _pSDL_GetDesktopDisplayMode = extern(C) int function(int displayIndex, SDL_DisplayMode* mode);
	alias _pSDL_GetCurrentDisplayMode = extern(C) int function(int displayIndex, SDL_DisplayMode* mode);
	alias _pSDL_GetClosestDisplayMode = extern(C) SDL_DisplayMode* function(int displayIndex, const(SDL_DisplayMode)* mode, SDL_DisplayMode* closest);
	alias _pSDL_GetWindowDisplayIndex = extern(C) int function(SDL_Window* window);
	alias _pSDL_SetWindowDisplayMode = extern(C) int function(SDL_Window* window, const(SDL_DisplayMode)* mode);
	alias _pSDL_GetWindowDisplayMode = extern(C) int function(SDL_Window* window, SDL_DisplayMode* mode);
	alias _pSDL_GetWindowPixelFormat = extern(C) uint function(SDL_Window* window);
	alias _pSDL_CreateWindow = extern(C) SDL_Window* function(const(char)* title, int x, int y, int w, int h, SDL_WindowFlags flags);
	alias _pSDL_CreateWindowFrom = extern(C) SDL_Window* function(const(void)* data);
	alias _pSDL_GetWindowID = extern(C) uint function(SDL_Window* window);
	alias _pSDL_GetWindowFromID = extern(C) SDL_Window* function(uint id);
	alias _pSDL_GetWindowFlags = extern(C) SDL_WindowFlags function(SDL_Window* window);
	alias _pSDL_SetWindowTitle = extern(C) void function(SDL_Window* window, const(char)* title);
	alias _pSDL_GetWindowTitle = extern(C) const(char)* function(SDL_Window* window);
	alias _pSDL_SetWindowIcon = extern(C) void function(SDL_Window* window, SDL_Surface* icon);
	alias _pSDL_SetWindowData = extern(C) void* function(SDL_Window* window, const(char)* name, void* userData);
	alias _pSDL_GetWindowData = extern(C) void* function(SDL_Window* window, const(char)* name);
	alias _pSDL_SetWindowPosition = extern(C) void function(SDL_Window* window, int x, int y);
	alias _pSDL_GetWindowPosition = extern(C) void function(SDL_Window* window, int* x, int* y);
	alias _pSDL_SetWindowSize = extern(C) void function(SDL_Window* window, int w, int h);
	alias _pSDL_GetWindowSize = extern(C) void function(SDL_Window* window, int* w, int* h);
	alias _pSDL_SetWindowMinimumSize = extern(C) void function(SDL_Window* window, int minW, int minH);
	alias _pSDL_GetWindowMinimumSize = extern(C) void function(SDL_Window* window, int* w, int* h);
	alias _pSDL_SetWindowMaximumSize = extern(C) void function(SDL_Window* window, int maxW, int maxH);
	alias _pSDL_GetWindowMaximumSize = extern(C) void function(SDL_Window* window, int* w, int* h);
	alias _pSDL_SetWindowBordered = extern(C) void function(SDL_Window* window, SDL_bool bordered);
	alias _pSDL_ShowWindow = extern(C) void function(SDL_Window* window);
	alias _pSDL_HideWindow = extern(C) void function(SDL_Window* window);
	alias _pSDL_RaiseWindow = extern(C) void function(SDL_Window* window);
	alias _pSDL_MaximizeWindow = extern(C) void function(SDL_Window* window);
	alias _pSDL_MinimizeWindow = extern(C) void function(SDL_Window* window);
	alias _pSDL_RestoreWindow = extern(C) void function(SDL_Window* window);
	alias _pSDL_SetWindowFullscreen = extern(C) int function(SDL_Window* window, SDL_WindowFlags flags);
	alias _pSDL_GetWindowSurface = extern(C) SDL_Surface* function(SDL_Window* window);
	alias _pSDL_UpdateWindowSurface = extern(C) int function(SDL_Window* window);
	alias _pSDL_UpdateWindowSurfaceRects = extern(C) int function(SDL_Window* window, SDL_Rect* rects, int numRects);
	alias _pSDL_SetWindowGrab = extern(C) void function(SDL_Window* window, SDL_bool grabbed);
	alias _pSDL_GetWindowGrab = extern(C) SDL_bool function(SDL_Window* window);
	alias _pSDL_SetWindowBrightness = extern(C) int function(SDL_Window* window, float brightness);
	alias _pSDL_GetWindowBrightness = extern(C) float function(SDL_Window* window);
	alias _pSDL_SetWindowGammaRamp = extern(C) int function(SDL_Window* window, const(ushort)* red, const(ushort)* green, const(ushort)* blue);
	alias _pSDL_GetWindowGammaRamp = extern(C) int function(SDL_Window* window, ushort* red, ushort* green, ushort* blue);
	alias _pSDL_DestroyWindow = extern(C) void function(SDL_Window* window);
	alias _pSDL_IsScreenSaverEnabled = extern(C) SDL_bool function();
	alias _pSDL_EnableScreenSaver = extern(C) void function();
	alias _pSDL_DisableScreenSaver = extern(C) void function();
	alias _pSDL_GL_LoadLibrary = extern(C) int function(const(char)* path);
	alias _pSDL_GL_GetProcAddress = extern(C) void* function(const(char)* proc);
	alias _pSDL_GL_UnloadLibrary = extern(C) void function();
	alias _pSDL_GL_ExtensionSupported = extern(C) SDL_bool function(const(char)* extension);
	alias _pSDL_GL_SetAttribute = extern(C) int function(SDL_GLattr attr, int value);
	alias _pSDL_GL_GetAttribute = extern(C) int function(SDL_GLattr attr, int* value);
	alias _pSDL_GL_CreateContext = extern(C) SDL_GLContext function(SDL_Window* window);
	alias _pSDL_GL_MakeCurrent = extern(C) int function(SDL_Window* window, SDL_GLContext context);
	alias _pSDL_GL_GetCurrentWindow = extern(C) SDL_Window* function();
	alias _pSDL_GL_GetCurrentContext = extern(C) SDL_GLContext function();
	alias _pSDL_GL_SetSwapInterval = extern(C) int function(int interval);
	alias _pSDL_GL_GetSwapInterval = extern(C) int function();
	alias _pSDL_GL_SwapWindow = extern(C) void function(SDL_Window* window);
	alias _pSDL_GL_DeleteContext = extern(C) void function(SDL_GLContext context);
}
__gshared nothrow @nogc{
	package _pSDL_GetNumVideoDrivers _SDL_GetNumVideoDrivers;
	extern(C) int SDL_GetNumVideoDrivers(){ return _SDL_GetNumVideoDrivers(__traits(parameters)); }
	package _pSDL_GetVideoDriver _SDL_GetVideoDriver;
	extern(C) const(char)* SDL_GetVideoDriver(int index){ return _SDL_GetVideoDriver(__traits(parameters)); }
	package _pSDL_VideoInit _SDL_VideoInit;
	extern(C) int SDL_VideoInit(const(char)* driverName){ return _SDL_VideoInit(__traits(parameters)); }
	package _pSDL_VideoQuit _SDL_VideoQuit;
	extern(C) void SDL_VideoQuit(){ _SDL_VideoQuit(__traits(parameters)); }
	package _pSDL_GetCurrentVideoDriver _SDL_GetCurrentVideoDriver;
	extern(C) const(char)* SDL_GetCurrentVideoDriver(){ return _SDL_GetCurrentVideoDriver(__traits(parameters)); }
	package _pSDL_GetNumVideoDisplays _SDL_GetNumVideoDisplays;
	extern(C) int SDL_GetNumVideoDisplays(){ return _SDL_GetNumVideoDisplays(__traits(parameters)); }
	package _pSDL_GetDisplayName _SDL_GetDisplayName;
	extern(C) const(char)* SDL_GetDisplayName(int displayIndex){ return _SDL_GetDisplayName(__traits(parameters)); }
	package _pSDL_GetDisplayBounds _SDL_GetDisplayBounds;
	extern(C) int SDL_GetDisplayBounds(int displayIndex, SDL_Rect* rect){ return _SDL_GetDisplayBounds(__traits(parameters)); }
	package _pSDL_GetNumDisplayModes _SDL_GetNumDisplayModes;
	extern(C) int SDL_GetNumDisplayModes(int displayIndex){ return _SDL_GetNumDisplayModes(__traits(parameters)); }
	package _pSDL_GetDisplayMode _SDL_GetDisplayMode;
	extern(C) int SDL_GetDisplayMode(int displayIndex, int modeIndex, SDL_DisplayMode* mode){ return _SDL_GetDisplayMode(__traits(parameters)); }
	package _pSDL_GetDesktopDisplayMode _SDL_GetDesktopDisplayMode;
	extern(C) int SDL_GetDesktopDisplayMode(int displayIndex, SDL_DisplayMode* mode){ return _SDL_GetDesktopDisplayMode(__traits(parameters)); }
	package _pSDL_GetCurrentDisplayMode _SDL_GetCurrentDisplayMode;
	extern(C) int SDL_GetCurrentDisplayMode(int displayIndex, SDL_DisplayMode* mode){ return _SDL_GetCurrentDisplayMode(__traits(parameters)); }
	package _pSDL_GetClosestDisplayMode _SDL_GetClosestDisplayMode;
	extern(C) SDL_DisplayMode* SDL_GetClosestDisplayMode(int displayIndex, const(SDL_DisplayMode)* mode, SDL_DisplayMode* closest){ return _SDL_GetClosestDisplayMode(__traits(parameters)); }
	package _pSDL_GetWindowDisplayIndex _SDL_GetWindowDisplayIndex;
	extern(C) int SDL_GetWindowDisplayIndex(SDL_Window* window){ return _SDL_GetWindowDisplayIndex(__traits(parameters)); }
	package _pSDL_SetWindowDisplayMode _SDL_SetWindowDisplayMode;
	extern(C) int SDL_SetWindowDisplayMode(SDL_Window* window, const(SDL_DisplayMode)* mode){ return _SDL_SetWindowDisplayMode(__traits(parameters)); }
	package _pSDL_GetWindowDisplayMode _SDL_GetWindowDisplayMode;
	extern(C) int SDL_GetWindowDisplayMode(SDL_Window* window, SDL_DisplayMode* mode){ return _SDL_GetWindowDisplayMode(__traits(parameters)); }
	package _pSDL_GetWindowPixelFormat _SDL_GetWindowPixelFormat;
	extern(C) uint SDL_GetWindowPixelFormat(SDL_Window* window){ return _SDL_GetWindowPixelFormat(__traits(parameters)); }
	package _pSDL_CreateWindow _SDL_CreateWindow;
	extern(C) SDL_Window* SDL_CreateWindow(const(char)* title, int x, int y, int w, int h, SDL_WindowFlags flags){ return _SDL_CreateWindow(__traits(parameters)); }
	package _pSDL_CreateWindowFrom _SDL_CreateWindowFrom;
	extern(C) SDL_Window* SDL_CreateWindowFrom(const(void)* data){ return _SDL_CreateWindowFrom(__traits(parameters)); }
	package _pSDL_GetWindowID _SDL_GetWindowID;
	extern(C) uint SDL_GetWindowID(SDL_Window* window){ return _SDL_GetWindowID(__traits(parameters)); }
	package _pSDL_GetWindowFromID _SDL_GetWindowFromID;
	extern(C) SDL_Window* SDL_GetWindowFromID(uint id){ return _SDL_GetWindowFromID(__traits(parameters)); }
	package _pSDL_GetWindowFlags _SDL_GetWindowFlags;
	extern(C) SDL_WindowFlags SDL_GetWindowFlags(SDL_Window* window){ return _SDL_GetWindowFlags(__traits(parameters)); }
	package _pSDL_SetWindowTitle _SDL_SetWindowTitle;
	extern(C) void SDL_SetWindowTitle(SDL_Window* window, const(char)* title){ _SDL_SetWindowTitle(__traits(parameters)); }
	package _pSDL_GetWindowTitle _SDL_GetWindowTitle;
	extern(C) const(char)* SDL_GetWindowTitle(SDL_Window* window){ return _SDL_GetWindowTitle(__traits(parameters)); }
	package _pSDL_SetWindowIcon _SDL_SetWindowIcon;
	extern(C) void SDL_SetWindowIcon(SDL_Window* window, SDL_Surface* icon){ _SDL_SetWindowIcon(__traits(parameters)); }
	package _pSDL_SetWindowData _SDL_SetWindowData;
	extern(C) void* SDL_SetWindowData(SDL_Window* window, const(char)* name, void* userData){ return _SDL_SetWindowData(__traits(parameters)); }
	package _pSDL_GetWindowData _SDL_GetWindowData;
	extern(C) void* SDL_GetWindowData(SDL_Window* window, const(char)* name){ return _SDL_GetWindowData(__traits(parameters)); }
	package _pSDL_SetWindowPosition _SDL_SetWindowPosition;
	extern(C) void SDL_SetWindowPosition(SDL_Window* window, int x, int y){ _SDL_SetWindowPosition(__traits(parameters)); }
	package _pSDL_GetWindowPosition _SDL_GetWindowPosition;
	extern(C) void SDL_GetWindowPosition(SDL_Window* window, int* x, int* y){ _SDL_GetWindowPosition(__traits(parameters)); }
	package _pSDL_SetWindowSize _SDL_SetWindowSize;
	extern(C) void SDL_SetWindowSize(SDL_Window* window, int w, int h){ _SDL_SetWindowSize(__traits(parameters)); }
	package _pSDL_GetWindowSize _SDL_GetWindowSize;
	extern(C) void SDL_GetWindowSize(SDL_Window* window, int* w, int* h){ _SDL_GetWindowSize(__traits(parameters)); }
	package _pSDL_SetWindowMinimumSize _SDL_SetWindowMinimumSize;
	extern(C) void SDL_SetWindowMinimumSize(SDL_Window* window, int minW, int minH){ _SDL_SetWindowMinimumSize(__traits(parameters)); }
	package _pSDL_GetWindowMinimumSize _SDL_GetWindowMinimumSize;
	extern(C) void SDL_GetWindowMinimumSize(SDL_Window* window, int* w, int* h){ _SDL_GetWindowMinimumSize(__traits(parameters)); }
	package _pSDL_SetWindowMaximumSize _SDL_SetWindowMaximumSize;
	extern(C) void SDL_SetWindowMaximumSize(SDL_Window* window, int maxW, int maxH){ _SDL_SetWindowMaximumSize(__traits(parameters)); }
	package _pSDL_GetWindowMaximumSize _SDL_GetWindowMaximumSize;
	extern(C) void SDL_GetWindowMaximumSize(SDL_Window* window, int* w, int* h){ _SDL_GetWindowMaximumSize(__traits(parameters)); }
	package _pSDL_SetWindowBordered _SDL_SetWindowBordered;
	extern(C) void SDL_SetWindowBordered(SDL_Window* window, SDL_bool bordered){ _SDL_SetWindowBordered(__traits(parameters)); }
	package _pSDL_ShowWindow _SDL_ShowWindow;
	extern(C) void SDL_ShowWindow(SDL_Window* window){ _SDL_ShowWindow(__traits(parameters)); }
	package _pSDL_HideWindow _SDL_HideWindow;
	extern(C) void SDL_HideWindow(SDL_Window* window){ _SDL_HideWindow(__traits(parameters)); }
	package _pSDL_RaiseWindow _SDL_RaiseWindow;
	extern(C) void SDL_RaiseWindow(SDL_Window* window){ _SDL_RaiseWindow(__traits(parameters)); }
	package _pSDL_MaximizeWindow _SDL_MaximizeWindow;
	extern(C) void SDL_MaximizeWindow(SDL_Window* window){ _SDL_MaximizeWindow(__traits(parameters)); }
	package _pSDL_MinimizeWindow _SDL_MinimizeWindow;
	extern(C) void SDL_MinimizeWindow(SDL_Window* window){ _SDL_MinimizeWindow(__traits(parameters)); }
	package _pSDL_RestoreWindow _SDL_RestoreWindow;
	extern(C) void SDL_RestoreWindow(SDL_Window* window){ _SDL_RestoreWindow(__traits(parameters)); }
	package _pSDL_SetWindowFullscreen _SDL_SetWindowFullscreen;
	extern(C) int SDL_SetWindowFullscreen(SDL_Window* window, SDL_WindowFlags flags){ return _SDL_SetWindowFullscreen(__traits(parameters)); }
	package _pSDL_GetWindowSurface _SDL_GetWindowSurface;
	extern(C) SDL_Surface* SDL_GetWindowSurface(SDL_Window* window){ return _SDL_GetWindowSurface(__traits(parameters)); }
	package _pSDL_UpdateWindowSurface _SDL_UpdateWindowSurface;
	extern(C) int SDL_UpdateWindowSurface(SDL_Window* window){ return _SDL_UpdateWindowSurface(__traits(parameters)); }
	package _pSDL_UpdateWindowSurfaceRects _SDL_UpdateWindowSurfaceRects;
	extern(C) int SDL_UpdateWindowSurfaceRects(SDL_Window* window, SDL_Rect* rects, int numRects){ return _SDL_UpdateWindowSurfaceRects(__traits(parameters)); }
	package _pSDL_SetWindowGrab _SDL_SetWindowGrab;
	extern(C) void SDL_SetWindowGrab(SDL_Window* window, SDL_bool grabbed){ _SDL_SetWindowGrab(__traits(parameters)); }
	package _pSDL_GetWindowGrab _SDL_GetWindowGrab;
	extern(C) SDL_bool SDL_GetWindowGrab(SDL_Window* window){ return _SDL_GetWindowGrab(__traits(parameters)); }
	package _pSDL_SetWindowBrightness _SDL_SetWindowBrightness;
	extern(C) int SDL_SetWindowBrightness(SDL_Window* window, float brightness){ return _SDL_SetWindowBrightness(__traits(parameters)); }
	package _pSDL_GetWindowBrightness _SDL_GetWindowBrightness;
	extern(C) float SDL_GetWindowBrightness(SDL_Window* window){ return _SDL_GetWindowBrightness(__traits(parameters)); }
	package _pSDL_SetWindowGammaRamp _SDL_SetWindowGammaRamp;
	extern(C) int SDL_SetWindowGammaRamp(SDL_Window* window, const(ushort)* red, const(ushort)* green, const(ushort)* blue){ return _SDL_SetWindowGammaRamp(__traits(parameters)); }
	package _pSDL_GetWindowGammaRamp _SDL_GetWindowGammaRamp;
	extern(C) int SDL_GetWindowGammaRamp(SDL_Window* window, ushort* red, ushort* green, ushort* blue){ return _SDL_GetWindowGammaRamp(__traits(parameters)); }
	package _pSDL_DestroyWindow _SDL_DestroyWindow;
	extern(C) void SDL_DestroyWindow(SDL_Window* window){ _SDL_DestroyWindow(__traits(parameters)); }
	package _pSDL_IsScreenSaverEnabled _SDL_IsScreenSaverEnabled;
	extern(C) SDL_bool SDL_IsScreenSaverEnabled(){ return _SDL_IsScreenSaverEnabled(__traits(parameters)); }
	package _pSDL_EnableScreenSaver _SDL_EnableScreenSaver;
	extern(C) void SDL_EnableScreenSaver(){ _SDL_EnableScreenSaver(__traits(parameters)); }
	package _pSDL_DisableScreenSaver _SDL_DisableScreenSaver;
	extern(C) void SDL_DisableScreenSaver(){ _SDL_DisableScreenSaver(__traits(parameters)); }
	package _pSDL_GL_LoadLibrary _SDL_GL_LoadLibrary;
	extern(C) int SDL_GL_LoadLibrary(const(char)* path){ return _SDL_GL_LoadLibrary(__traits(parameters)); }
	package _pSDL_GL_GetProcAddress _SDL_GL_GetProcAddress;
	extern(C) void* SDL_GL_GetProcAddress(const(char)* proc){ return _SDL_GL_GetProcAddress(__traits(parameters)); }
	package _pSDL_GL_UnloadLibrary _SDL_GL_UnloadLibrary;
	extern(C) void SDL_GL_UnloadLibrary(){ _SDL_GL_UnloadLibrary(__traits(parameters)); }
	package _pSDL_GL_ExtensionSupported _SDL_GL_ExtensionSupported;
	extern(C) SDL_bool SDL_GL_ExtensionSupported(const(char)* extension){ return _SDL_GL_ExtensionSupported(__traits(parameters)); }
	package _pSDL_GL_SetAttribute _SDL_GL_SetAttribute;
	extern(C) int SDL_GL_SetAttribute(SDL_GLattr attr, int value){ return _SDL_GL_SetAttribute(__traits(parameters)); }
	package _pSDL_GL_GetAttribute _SDL_GL_GetAttribute;
	extern(C) int SDL_GL_GetAttribute(SDL_GLattr attr, int* value){ return _SDL_GL_GetAttribute(__traits(parameters)); }
	package _pSDL_GL_CreateContext _SDL_GL_CreateContext;
	extern(C) SDL_GLContext SDL_GL_CreateContext(SDL_Window* window){ return _SDL_GL_CreateContext(__traits(parameters)); }
	package _pSDL_GL_MakeCurrent _SDL_GL_MakeCurrent;
	extern(C) int SDL_GL_MakeCurrent(SDL_Window* window, SDL_GLContext context){ return _SDL_GL_MakeCurrent(__traits(parameters)); }
	package _pSDL_GL_GetCurrentWindow _SDL_GL_GetCurrentWindow;
	extern(C) SDL_Window* SDL_GL_GetCurrentWindow(){ return _SDL_GL_GetCurrentWindow(__traits(parameters)); }
	package _pSDL_GL_GetCurrentContext _SDL_GL_GetCurrentContext;
	extern(C) SDL_GLContext SDL_GL_GetCurrentContext(){ return _SDL_GL_GetCurrentContext(__traits(parameters)); }
	package _pSDL_GL_SetSwapInterval _SDL_GL_SetSwapInterval;
	extern(C) int SDL_GL_SetSwapInterval(int interval){ return _SDL_GL_SetSwapInterval(__traits(parameters)); }
	package _pSDL_GL_GetSwapInterval _SDL_GL_GetSwapInterval;
	extern(C) int SDL_GL_GetSwapInterval(){ return _SDL_GL_GetSwapInterval(__traits(parameters)); }
	package _pSDL_GL_SwapWindow _SDL_GL_SwapWindow;
	extern(C) void SDL_GL_SwapWindow(SDL_Window* window){ _SDL_GL_SwapWindow(__traits(parameters)); }
	package _pSDL_GL_DeleteContext _SDL_GL_DeleteContext;
	extern(C) void SDL_GL_DeleteContext(SDL_GLContext context){ _SDL_GL_DeleteContext(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetNumVideoDrivers, here.SDL_GetNumVideoDrivers.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetVideoDriver, here.SDL_GetVideoDriver.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_VideoInit, here.SDL_VideoInit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_VideoQuit, here.SDL_VideoQuit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetCurrentVideoDriver, here.SDL_GetCurrentVideoDriver.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetNumVideoDisplays, here.SDL_GetNumVideoDisplays.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetDisplayName, here.SDL_GetDisplayName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetDisplayBounds, here.SDL_GetDisplayBounds.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetNumDisplayModes, here.SDL_GetNumDisplayModes.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetDisplayMode, here.SDL_GetDisplayMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetDesktopDisplayMode, here.SDL_GetDesktopDisplayMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetCurrentDisplayMode, here.SDL_GetCurrentDisplayMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetClosestDisplayMode, here.SDL_GetClosestDisplayMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowDisplayIndex, here.SDL_GetWindowDisplayIndex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowDisplayMode, here.SDL_SetWindowDisplayMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowDisplayMode, here.SDL_GetWindowDisplayMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowPixelFormat, here.SDL_GetWindowPixelFormat.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateWindow, here.SDL_CreateWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateWindowFrom, here.SDL_CreateWindowFrom.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowID, here.SDL_GetWindowID.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowFromID, here.SDL_GetWindowFromID.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowFlags, here.SDL_GetWindowFlags.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowTitle, here.SDL_SetWindowTitle.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowTitle, here.SDL_GetWindowTitle.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowIcon, here.SDL_SetWindowIcon.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowData, here.SDL_SetWindowData.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowData, here.SDL_GetWindowData.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowPosition, here.SDL_SetWindowPosition.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowPosition, here.SDL_GetWindowPosition.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowSize, here.SDL_SetWindowSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowSize, here.SDL_GetWindowSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowMinimumSize, here.SDL_SetWindowMinimumSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowMinimumSize, here.SDL_GetWindowMinimumSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowMaximumSize, here.SDL_SetWindowMaximumSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowMaximumSize, here.SDL_GetWindowMaximumSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowBordered, here.SDL_SetWindowBordered.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ShowWindow, here.SDL_ShowWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HideWindow, here.SDL_HideWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RaiseWindow, here.SDL_RaiseWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_MaximizeWindow, here.SDL_MaximizeWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_MinimizeWindow, here.SDL_MinimizeWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RestoreWindow, here.SDL_RestoreWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowFullscreen, here.SDL_SetWindowFullscreen.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowSurface, here.SDL_GetWindowSurface.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UpdateWindowSurface, here.SDL_UpdateWindowSurface.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UpdateWindowSurfaceRects, here.SDL_UpdateWindowSurfaceRects.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowGrab, here.SDL_SetWindowGrab.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowGrab, here.SDL_GetWindowGrab.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowBrightness, here.SDL_SetWindowBrightness.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowBrightness, here.SDL_GetWindowBrightness.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowGammaRamp, here.SDL_SetWindowGammaRamp.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetWindowGammaRamp, here.SDL_GetWindowGammaRamp.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DestroyWindow, here.SDL_DestroyWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_IsScreenSaverEnabled, here.SDL_IsScreenSaverEnabled.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_EnableScreenSaver, here.SDL_EnableScreenSaver.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DisableScreenSaver, here.SDL_DisableScreenSaver.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_LoadLibrary, here.SDL_GL_LoadLibrary.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_GetProcAddress, here.SDL_GL_GetProcAddress.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_UnloadLibrary, here.SDL_GL_UnloadLibrary.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_ExtensionSupported, here.SDL_GL_ExtensionSupported.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_SetAttribute, here.SDL_GL_SetAttribute.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_GetAttribute, here.SDL_GL_GetAttribute.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_CreateContext, here.SDL_GL_CreateContext.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_MakeCurrent, here.SDL_GL_MakeCurrent.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_GetCurrentWindow, here.SDL_GL_GetCurrentWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_GetCurrentContext, here.SDL_GL_GetCurrentContext.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_SetSwapInterval, here.SDL_GL_SetSwapInterval.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_GetSwapInterval, here.SDL_GL_GetSwapInterval.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_SwapWindow, here.SDL_GL_SwapWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_DeleteContext, here.SDL_GL_DeleteContext.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/keyboard.d(26,1)
private nothrow @nogc{
	alias _pSDL_GetKeyboardFocus = extern(C) SDL_Window* function();
	alias _pSDL_GetKeyboardState = extern(C) ubyte* function(int* numKeys);
	alias _pSDL_GetModState = extern(C) SDL_Keymod function();
	alias _pSDL_SetModState = extern(C) void function(SDL_Keymod modState);
	alias _pSDL_GetKeyFromScancode = extern(C) SDL_KeyCode function(SDL_Scancode scancode);
	alias _pSDL_GetScancodeFromKey = extern(C) SDL_Scancode function(SDL_KeyCode key);
	alias _pSDL_GetScancodeName = extern(C) const(char)* function(SDL_Scancode scancode);
	alias _pSDL_GetScancodeFromName = extern(C) SDL_Scancode function(const(char)* name);
	alias _pSDL_GetKeyName = extern(C) const(char)* function(SDL_KeyCode key);
	alias _pSDL_GetKeyFromName = extern(C) SDL_KeyCode function(const(char)* name);
	alias _pSDL_StartTextInput = extern(C) void function();
	alias _pSDL_IsTextInputActive = extern(C) SDL_bool function();
	alias _pSDL_StopTextInput = extern(C) void function();
	alias _pSDL_HasScreenKeyboardSupport = extern(C) SDL_bool function();
	alias _pSDL_IsScreenKeyboardShown = extern(C) SDL_bool function(SDL_Window* window);
	alias _pSDL_SetTextInputRect = extern(C) void function(SDL_Rect* rect);
}
__gshared nothrow @nogc{
	package _pSDL_GetKeyboardFocus _SDL_GetKeyboardFocus;
	extern(C) SDL_Window* SDL_GetKeyboardFocus(){ return _SDL_GetKeyboardFocus(__traits(parameters)); }
	package _pSDL_GetKeyboardState _SDL_GetKeyboardState;
	extern(C) ubyte* SDL_GetKeyboardState(int* numKeys){ return _SDL_GetKeyboardState(__traits(parameters)); }
	package _pSDL_GetModState _SDL_GetModState;
	extern(C) SDL_Keymod SDL_GetModState(){ return _SDL_GetModState(__traits(parameters)); }
	package _pSDL_SetModState _SDL_SetModState;
	extern(C) void SDL_SetModState(SDL_Keymod modState){ _SDL_SetModState(__traits(parameters)); }
	package _pSDL_GetKeyFromScancode _SDL_GetKeyFromScancode;
	extern(C) SDL_KeyCode SDL_GetKeyFromScancode(SDL_Scancode scancode){ return _SDL_GetKeyFromScancode(__traits(parameters)); }
	package _pSDL_GetScancodeFromKey _SDL_GetScancodeFromKey;
	extern(C) SDL_Scancode SDL_GetScancodeFromKey(SDL_KeyCode key){ return _SDL_GetScancodeFromKey(__traits(parameters)); }
	package _pSDL_GetScancodeName _SDL_GetScancodeName;
	extern(C) const(char)* SDL_GetScancodeName(SDL_Scancode scancode){ return _SDL_GetScancodeName(__traits(parameters)); }
	package _pSDL_GetScancodeFromName _SDL_GetScancodeFromName;
	extern(C) SDL_Scancode SDL_GetScancodeFromName(const(char)* name){ return _SDL_GetScancodeFromName(__traits(parameters)); }
	package _pSDL_GetKeyName _SDL_GetKeyName;
	extern(C) const(char)* SDL_GetKeyName(SDL_KeyCode key){ return _SDL_GetKeyName(__traits(parameters)); }
	package _pSDL_GetKeyFromName _SDL_GetKeyFromName;
	extern(C) SDL_KeyCode SDL_GetKeyFromName(const(char)* name){ return _SDL_GetKeyFromName(__traits(parameters)); }
	package _pSDL_StartTextInput _SDL_StartTextInput;
	extern(C) void SDL_StartTextInput(){ _SDL_StartTextInput(__traits(parameters)); }
	package _pSDL_IsTextInputActive _SDL_IsTextInputActive;
	extern(C) SDL_bool SDL_IsTextInputActive(){ return _SDL_IsTextInputActive(__traits(parameters)); }
	package _pSDL_StopTextInput _SDL_StopTextInput;
	extern(C) void SDL_StopTextInput(){ _SDL_StopTextInput(__traits(parameters)); }
	package _pSDL_HasScreenKeyboardSupport _SDL_HasScreenKeyboardSupport;
	extern(C) SDL_bool SDL_HasScreenKeyboardSupport(){ return _SDL_HasScreenKeyboardSupport(__traits(parameters)); }
	package _pSDL_IsScreenKeyboardShown _SDL_IsScreenKeyboardShown;
	extern(C) SDL_bool SDL_IsScreenKeyboardShown(SDL_Window* window){ return _SDL_IsScreenKeyboardShown(__traits(parameters)); }
	package _pSDL_SetTextInputRect _SDL_SetTextInputRect;
	extern(C) void SDL_SetTextInputRect(SDL_Rect* rect){ _SDL_SetTextInputRect(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetKeyboardFocus, here.SDL_GetKeyboardFocus.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetKeyboardState, here.SDL_GetKeyboardState.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetModState, here.SDL_GetModState.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetModState, here.SDL_SetModState.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetKeyFromScancode, here.SDL_GetKeyFromScancode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetScancodeFromKey, here.SDL_GetScancodeFromKey.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetScancodeName, here.SDL_GetScancodeName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetScancodeFromName, here.SDL_GetScancodeFromName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetKeyName, here.SDL_GetKeyName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetKeyFromName, here.SDL_GetKeyFromName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_StartTextInput, here.SDL_StartTextInput.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_IsTextInputActive, here.SDL_IsTextInputActive.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_StopTextInput, here.SDL_StopTextInput.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasScreenKeyboardSupport, here.SDL_HasScreenKeyboardSupport.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_IsScreenKeyboardShown, here.SDL_IsScreenKeyboardShown.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetTextInputRect, here.SDL_SetTextInputRect.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/syswm.d(244,1)
private nothrow @nogc{
	alias _pSDL_GetWindowWMInfo = extern(C) SDL_bool function(SDL_Window* window, SDL_SysWMinfo* info);
}
__gshared nothrow @nogc{
	package _pSDL_GetWindowWMInfo _SDL_GetWindowWMInfo;
	extern(C) SDL_bool SDL_GetWindowWMInfo(SDL_Window* window, SDL_SysWMinfo* info){ return _SDL_GetWindowWMInfo(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetWindowWMInfo, here.SDL_GetWindowWMInfo.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/events.d(517,1)
private nothrow @nogc{
	alias _pSDL_PumpEvents = extern(C) void function();
	alias _pSDL_PeepEvents = extern(C) int function(SDL_Event* events, int numEvents, SDL_eventaction action, SDL_EventType minType, SDL_EventType maxType);
	alias _pSDL_HasEvent = extern(C) SDL_bool function(SDL_EventType type);
	alias _pSDL_HasEvents = extern(C) SDL_bool function(SDL_EventType minType, SDL_EventType maxType);
	alias _pSDL_FlushEvent = extern(C) void function(SDL_EventType type);
	alias _pSDL_FlushEvents = extern(C) void function(SDL_EventType minType, SDL_EventType maxType);
	alias _pSDL_PollEvent = extern(C) int function(SDL_Event* event);
	alias _pSDL_WaitEvent = extern(C) int function(SDL_Event* event);
	alias _pSDL_WaitEventTimeout = extern(C) int function(SDL_Event* event, int timeout);
	alias _pSDL_PushEvent = extern(C) int function(SDL_Event* event);
	alias _pSDL_SetEventFilter = extern(C) void function(SDL_EventFilter filter, void* userData);
	alias _pSDL_GetEventFilter = extern(C) SDL_bool function(SDL_EventFilter* filter, void** userData);
	alias _pSDL_AddEventWatch = extern(C) void function(SDL_EventFilter filter, void* userData);
	alias _pSDL_DelEventWatch = extern(C) void function(SDL_EventFilter filter, void* userData);
	alias _pSDL_FilterEvents = extern(C) void function(SDL_EventFilter filter, void* userData);
	alias _pSDL_EventState = extern(C) ubyte function(SDL_EventType type, int state);
	alias _pSDL_RegisterEvents = extern(C) SDL_EventType function(int numEvents);
}
__gshared nothrow @nogc{
	package _pSDL_PumpEvents _SDL_PumpEvents;
	extern(C) void SDL_PumpEvents(){ _SDL_PumpEvents(__traits(parameters)); }
	package _pSDL_PeepEvents _SDL_PeepEvents;
	extern(C) int SDL_PeepEvents(SDL_Event* events, int numEvents, SDL_eventaction action, SDL_EventType minType, SDL_EventType maxType){ return _SDL_PeepEvents(__traits(parameters)); }
	package _pSDL_HasEvent _SDL_HasEvent;
	extern(C) SDL_bool SDL_HasEvent(SDL_EventType type){ return _SDL_HasEvent(__traits(parameters)); }
	package _pSDL_HasEvents _SDL_HasEvents;
	extern(C) SDL_bool SDL_HasEvents(SDL_EventType minType, SDL_EventType maxType){ return _SDL_HasEvents(__traits(parameters)); }
	package _pSDL_FlushEvent _SDL_FlushEvent;
	extern(C) void SDL_FlushEvent(SDL_EventType type){ _SDL_FlushEvent(__traits(parameters)); }
	package _pSDL_FlushEvents _SDL_FlushEvents;
	extern(C) void SDL_FlushEvents(SDL_EventType minType, SDL_EventType maxType){ _SDL_FlushEvents(__traits(parameters)); }
	package _pSDL_PollEvent _SDL_PollEvent;
	extern(C) int SDL_PollEvent(SDL_Event* event){ return _SDL_PollEvent(__traits(parameters)); }
	package _pSDL_WaitEvent _SDL_WaitEvent;
	extern(C) int SDL_WaitEvent(SDL_Event* event){ return _SDL_WaitEvent(__traits(parameters)); }
	package _pSDL_WaitEventTimeout _SDL_WaitEventTimeout;
	extern(C) int SDL_WaitEventTimeout(SDL_Event* event, int timeout){ return _SDL_WaitEventTimeout(__traits(parameters)); }
	package _pSDL_PushEvent _SDL_PushEvent;
	extern(C) int SDL_PushEvent(SDL_Event* event){ return _SDL_PushEvent(__traits(parameters)); }
	package _pSDL_SetEventFilter _SDL_SetEventFilter;
	extern(C) void SDL_SetEventFilter(SDL_EventFilter filter, void* userData){ _SDL_SetEventFilter(__traits(parameters)); }
	package _pSDL_GetEventFilter _SDL_GetEventFilter;
	extern(C) SDL_bool SDL_GetEventFilter(SDL_EventFilter* filter, void** userData){ return _SDL_GetEventFilter(__traits(parameters)); }
	package _pSDL_AddEventWatch _SDL_AddEventWatch;
	extern(C) void SDL_AddEventWatch(SDL_EventFilter filter, void* userData){ _SDL_AddEventWatch(__traits(parameters)); }
	package _pSDL_DelEventWatch _SDL_DelEventWatch;
	extern(C) void SDL_DelEventWatch(SDL_EventFilter filter, void* userData){ _SDL_DelEventWatch(__traits(parameters)); }
	package _pSDL_FilterEvents _SDL_FilterEvents;
	extern(C) void SDL_FilterEvents(SDL_EventFilter filter, void* userData){ _SDL_FilterEvents(__traits(parameters)); }
	package _pSDL_EventState _SDL_EventState;
	extern(C) ubyte SDL_EventState(SDL_EventType type, int state){ return _SDL_EventState(__traits(parameters)); }
	package _pSDL_RegisterEvents _SDL_RegisterEvents;
	extern(C) SDL_EventType SDL_RegisterEvents(int numEvents){ return _SDL_RegisterEvents(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_PumpEvents, here.SDL_PumpEvents.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_PeepEvents, here.SDL_PeepEvents.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasEvent, here.SDL_HasEvent.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HasEvents, here.SDL_HasEvents.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FlushEvent, here.SDL_FlushEvent.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FlushEvents, here.SDL_FlushEvents.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_PollEvent, here.SDL_PollEvent.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WaitEvent, here.SDL_WaitEvent.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WaitEventTimeout, here.SDL_WaitEventTimeout.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_PushEvent, here.SDL_PushEvent.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetEventFilter, here.SDL_SetEventFilter.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetEventFilter, here.SDL_GetEventFilter.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AddEventWatch, here.SDL_AddEventWatch.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DelEventWatch, here.SDL_DelEventWatch.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FilterEvents, here.SDL_FilterEvents.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_EventState, here.SDL_EventState.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RegisterEvents, here.SDL_RegisterEvents.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/filesystem.d(13,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/sensor.d(36,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/gamecontroller.d(127,1)
private nothrow @nogc{
	alias _pSDL_GameControllerAddMapping = extern(C) int function(const(char)* mappingString);
	alias _pSDL_GameControllerMappingForGUID = extern(C) char* function(SDL_JoystickGUID guid);
	alias _pSDL_GameControllerMapping = extern(C) char* function(SDL_GameController* gameController);
	alias _pSDL_IsGameController = extern(C) SDL_bool function(int joystickIndex);
	alias _pSDL_GameControllerNameForIndex = extern(C) const(char)* function(int joystickIndex);
	alias _pSDL_GameControllerOpen = extern(C) SDL_GameController* function(int joystickIndex);
	alias _pSDL_GameControllerName = extern(C) const(char)* function(SDL_GameController* gameController);
	alias _pSDL_GameControllerGetAttached = extern(C) SDL_bool function(SDL_GameController* gameController);
	alias _pSDL_GameControllerGetJoystick = extern(C) SDL_Joystick* function(SDL_GameController* gameController);
	alias _pSDL_GameControllerEventState = extern(C) int function(int state);
	alias _pSDL_GameControllerUpdate = extern(C) void function();
	alias _pSDL_GameControllerGetAxisFromString = extern(C) SDL_GameControllerAxis function(const(char)* pchString);
	alias _pSDL_GameControllerGetStringForAxis = extern(C) const(char)* function(SDL_GameControllerAxis axis);
	alias _pSDL_GameControllerGetBindForAxis = extern(C) SDL_GameControllerButtonBind function(SDL_GameController* gameController, SDL_GameControllerAxis axis);
	alias _pSDL_GameControllerGetAxis = extern(C) short function(SDL_GameController* gameController, SDL_GameControllerAxis axis);
	alias _pSDL_GameControllerGetButtonFromString = extern(C) SDL_GameControllerButton function(const(char*) pchString);
	alias _pSDL_GameControllerGetStringForButton = extern(C) const(char)* function(SDL_GameControllerButton button);
	alias _pSDL_GameControllerGetBindForButton = extern(C) SDL_GameControllerButtonBind function(SDL_GameController* gameController, SDL_GameControllerButton button);
	alias _pSDL_GameControllerGetButton = extern(C) ubyte function(SDL_GameController* gameController, SDL_GameControllerButton button);
	alias _pSDL_GameControllerClose = extern(C) void function(SDL_GameController* gameController);
}
__gshared nothrow @nogc{
	package _pSDL_GameControllerAddMapping _SDL_GameControllerAddMapping;
	extern(C) int SDL_GameControllerAddMapping(const(char)* mappingString){ return _SDL_GameControllerAddMapping(__traits(parameters)); }
	package _pSDL_GameControllerMappingForGUID _SDL_GameControllerMappingForGUID;
	extern(C) char* SDL_GameControllerMappingForGUID(SDL_JoystickGUID guid){ return _SDL_GameControllerMappingForGUID(__traits(parameters)); }
	package _pSDL_GameControllerMapping _SDL_GameControllerMapping;
	extern(C) char* SDL_GameControllerMapping(SDL_GameController* gameController){ return _SDL_GameControllerMapping(__traits(parameters)); }
	package _pSDL_IsGameController _SDL_IsGameController;
	extern(C) SDL_bool SDL_IsGameController(int joystickIndex){ return _SDL_IsGameController(__traits(parameters)); }
	package _pSDL_GameControllerNameForIndex _SDL_GameControllerNameForIndex;
	extern(C) const(char)* SDL_GameControllerNameForIndex(int joystickIndex){ return _SDL_GameControllerNameForIndex(__traits(parameters)); }
	package _pSDL_GameControllerOpen _SDL_GameControllerOpen;
	extern(C) SDL_GameController* SDL_GameControllerOpen(int joystickIndex){ return _SDL_GameControllerOpen(__traits(parameters)); }
	package _pSDL_GameControllerName _SDL_GameControllerName;
	extern(C) const(char)* SDL_GameControllerName(SDL_GameController* gameController){ return _SDL_GameControllerName(__traits(parameters)); }
	package _pSDL_GameControllerGetAttached _SDL_GameControllerGetAttached;
	extern(C) SDL_bool SDL_GameControllerGetAttached(SDL_GameController* gameController){ return _SDL_GameControllerGetAttached(__traits(parameters)); }
	package _pSDL_GameControllerGetJoystick _SDL_GameControllerGetJoystick;
	extern(C) SDL_Joystick* SDL_GameControllerGetJoystick(SDL_GameController* gameController){ return _SDL_GameControllerGetJoystick(__traits(parameters)); }
	package _pSDL_GameControllerEventState _SDL_GameControllerEventState;
	extern(C) int SDL_GameControllerEventState(int state){ return _SDL_GameControllerEventState(__traits(parameters)); }
	package _pSDL_GameControllerUpdate _SDL_GameControllerUpdate;
	extern(C) void SDL_GameControllerUpdate(){ _SDL_GameControllerUpdate(__traits(parameters)); }
	package _pSDL_GameControllerGetAxisFromString _SDL_GameControllerGetAxisFromString;
	extern(C) SDL_GameControllerAxis SDL_GameControllerGetAxisFromString(const(char)* pchString){ return _SDL_GameControllerGetAxisFromString(__traits(parameters)); }
	package _pSDL_GameControllerGetStringForAxis _SDL_GameControllerGetStringForAxis;
	extern(C) const(char)* SDL_GameControllerGetStringForAxis(SDL_GameControllerAxis axis){ return _SDL_GameControllerGetStringForAxis(__traits(parameters)); }
	package _pSDL_GameControllerGetBindForAxis _SDL_GameControllerGetBindForAxis;
	extern(C) SDL_GameControllerButtonBind SDL_GameControllerGetBindForAxis(SDL_GameController* gameController, SDL_GameControllerAxis axis){ return _SDL_GameControllerGetBindForAxis(__traits(parameters)); }
	package _pSDL_GameControllerGetAxis _SDL_GameControllerGetAxis;
	extern(C) short SDL_GameControllerGetAxis(SDL_GameController* gameController, SDL_GameControllerAxis axis){ return _SDL_GameControllerGetAxis(__traits(parameters)); }
	package _pSDL_GameControllerGetButtonFromString _SDL_GameControllerGetButtonFromString;
	extern(C) SDL_GameControllerButton SDL_GameControllerGetButtonFromString(const(char*) pchString){ return _SDL_GameControllerGetButtonFromString(__traits(parameters)); }
	package _pSDL_GameControllerGetStringForButton _SDL_GameControllerGetStringForButton;
	extern(C) const(char)* SDL_GameControllerGetStringForButton(SDL_GameControllerButton button){ return _SDL_GameControllerGetStringForButton(__traits(parameters)); }
	package _pSDL_GameControllerGetBindForButton _SDL_GameControllerGetBindForButton;
	extern(C) SDL_GameControllerButtonBind SDL_GameControllerGetBindForButton(SDL_GameController* gameController, SDL_GameControllerButton button){ return _SDL_GameControllerGetBindForButton(__traits(parameters)); }
	package _pSDL_GameControllerGetButton _SDL_GameControllerGetButton;
	extern(C) ubyte SDL_GameControllerGetButton(SDL_GameController* gameController, SDL_GameControllerButton button){ return _SDL_GameControllerGetButton(__traits(parameters)); }
	package _pSDL_GameControllerClose _SDL_GameControllerClose;
	extern(C) void SDL_GameControllerClose(SDL_GameController* gameController){ _SDL_GameControllerClose(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GameControllerAddMapping, here.SDL_GameControllerAddMapping.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerMappingForGUID, here.SDL_GameControllerMappingForGUID.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerMapping, here.SDL_GameControllerMapping.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_IsGameController, here.SDL_IsGameController.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerNameForIndex, here.SDL_GameControllerNameForIndex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerOpen, here.SDL_GameControllerOpen.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerName, here.SDL_GameControllerName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetAttached, here.SDL_GameControllerGetAttached.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetJoystick, here.SDL_GameControllerGetJoystick.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerEventState, here.SDL_GameControllerEventState.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerUpdate, here.SDL_GameControllerUpdate.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetAxisFromString, here.SDL_GameControllerGetAxisFromString.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetStringForAxis, here.SDL_GameControllerGetStringForAxis.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetBindForAxis, here.SDL_GameControllerGetBindForAxis.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetAxis, here.SDL_GameControllerGetAxis.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetButtonFromString, here.SDL_GameControllerGetButtonFromString.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetStringForButton, here.SDL_GameControllerGetStringForButton.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetBindForButton, here.SDL_GameControllerGetBindForButton.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerGetButton, here.SDL_GameControllerGetButton.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GameControllerClose, here.SDL_GameControllerClose.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/hidapi.d(36,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/haptic.d(168,1)
private nothrow @nogc{
	alias _pSDL_NumHaptics = extern(C) int function();
	alias _pSDL_HapticName = extern(C) const(char)* function(int deviceIndex);
	alias _pSDL_HapticOpen = extern(C) SDL_Haptic* function(int deviceIndex);
	alias _pSDL_HapticOpened = extern(C) int function(int deviceIndex);
	alias _pSDL_HapticIndex = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_MouseIsHaptic = extern(C) int function();
	alias _pSDL_HapticOpenFromMouse = extern(C) SDL_Haptic* function();
	alias _pSDL_JoystickIsHaptic = extern(C) int function(SDL_Joystick* joystick);
	alias _pSDL_HapticOpenFromJoystick = extern(C) SDL_Haptic* function(SDL_Joystick* joystick);
	alias _pSDL_HapticClose = extern(C) void function(SDL_Haptic* haptic);
	alias _pSDL_HapticNumEffects = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_HapticNumEffectsPlaying = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_HapticQuery = extern(C) uint function(SDL_Haptic* haptic);
	alias _pSDL_HapticNumAxes = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_HapticEffectSupported = extern(C) int function(SDL_Haptic* haptic, SDL_HapticEffect* effect);
	alias _pSDL_HapticNewEffect = extern(C) int function(SDL_Haptic* haptic, SDL_HapticEffect* effect);
	alias _pSDL_HapticUpdateEffect = extern(C) int function(SDL_Haptic* haptic, int effect, SDL_HapticEffect* data);
	alias _pSDL_HapticRunEffect = extern(C) int function(SDL_Haptic* haptic, int effect, uint iterations);
	alias _pSDL_HapticStopEffect = extern(C) int function(SDL_Haptic* haptic, int effect);
	alias _pSDL_HapticDestroyEffect = extern(C) int function(SDL_Haptic* haptic, int effect);
	alias _pSDL_HapticGetEffectStatus = extern(C) int function(SDL_Haptic* haptic, int effect);
	alias _pSDL_HapticSetGain = extern(C) int function(SDL_Haptic* haptic, int gain);
	alias _pSDL_HapticSetAutocenter = extern(C) int function(SDL_Haptic* haptic, int autocentre);
	alias _pSDL_HapticPause = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_HapticUnpause = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_HapticStopAll = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_HapticRumbleSupported = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_HapticRumbleInit = extern(C) int function(SDL_Haptic* haptic);
	alias _pSDL_HapticRumblePlay = extern(C) int function(SDL_Haptic* haptic, float strength, uint length);
	alias _pSDL_HapticRumbleStop = extern(C) int function(SDL_Haptic* haptic);
}
__gshared nothrow @nogc{
	package _pSDL_NumHaptics _SDL_NumHaptics;
	extern(C) int SDL_NumHaptics(){ return _SDL_NumHaptics(__traits(parameters)); }
	package _pSDL_HapticName _SDL_HapticName;
	extern(C) const(char)* SDL_HapticName(int deviceIndex){ return _SDL_HapticName(__traits(parameters)); }
	package _pSDL_HapticOpen _SDL_HapticOpen;
	extern(C) SDL_Haptic* SDL_HapticOpen(int deviceIndex){ return _SDL_HapticOpen(__traits(parameters)); }
	package _pSDL_HapticOpened _SDL_HapticOpened;
	extern(C) int SDL_HapticOpened(int deviceIndex){ return _SDL_HapticOpened(__traits(parameters)); }
	package _pSDL_HapticIndex _SDL_HapticIndex;
	extern(C) int SDL_HapticIndex(SDL_Haptic* haptic){ return _SDL_HapticIndex(__traits(parameters)); }
	package _pSDL_MouseIsHaptic _SDL_MouseIsHaptic;
	extern(C) int SDL_MouseIsHaptic(){ return _SDL_MouseIsHaptic(__traits(parameters)); }
	package _pSDL_HapticOpenFromMouse _SDL_HapticOpenFromMouse;
	extern(C) SDL_Haptic* SDL_HapticOpenFromMouse(){ return _SDL_HapticOpenFromMouse(__traits(parameters)); }
	package _pSDL_JoystickIsHaptic _SDL_JoystickIsHaptic;
	extern(C) int SDL_JoystickIsHaptic(SDL_Joystick* joystick){ return _SDL_JoystickIsHaptic(__traits(parameters)); }
	package _pSDL_HapticOpenFromJoystick _SDL_HapticOpenFromJoystick;
	extern(C) SDL_Haptic* SDL_HapticOpenFromJoystick(SDL_Joystick* joystick){ return _SDL_HapticOpenFromJoystick(__traits(parameters)); }
	package _pSDL_HapticClose _SDL_HapticClose;
	extern(C) void SDL_HapticClose(SDL_Haptic* haptic){ _SDL_HapticClose(__traits(parameters)); }
	package _pSDL_HapticNumEffects _SDL_HapticNumEffects;
	extern(C) int SDL_HapticNumEffects(SDL_Haptic* haptic){ return _SDL_HapticNumEffects(__traits(parameters)); }
	package _pSDL_HapticNumEffectsPlaying _SDL_HapticNumEffectsPlaying;
	extern(C) int SDL_HapticNumEffectsPlaying(SDL_Haptic* haptic){ return _SDL_HapticNumEffectsPlaying(__traits(parameters)); }
	package _pSDL_HapticQuery _SDL_HapticQuery;
	extern(C) uint SDL_HapticQuery(SDL_Haptic* haptic){ return _SDL_HapticQuery(__traits(parameters)); }
	package _pSDL_HapticNumAxes _SDL_HapticNumAxes;
	extern(C) int SDL_HapticNumAxes(SDL_Haptic* haptic){ return _SDL_HapticNumAxes(__traits(parameters)); }
	package _pSDL_HapticEffectSupported _SDL_HapticEffectSupported;
	extern(C) int SDL_HapticEffectSupported(SDL_Haptic* haptic, SDL_HapticEffect* effect){ return _SDL_HapticEffectSupported(__traits(parameters)); }
	package _pSDL_HapticNewEffect _SDL_HapticNewEffect;
	extern(C) int SDL_HapticNewEffect(SDL_Haptic* haptic, SDL_HapticEffect* effect){ return _SDL_HapticNewEffect(__traits(parameters)); }
	package _pSDL_HapticUpdateEffect _SDL_HapticUpdateEffect;
	extern(C) int SDL_HapticUpdateEffect(SDL_Haptic* haptic, int effect, SDL_HapticEffect* data){ return _SDL_HapticUpdateEffect(__traits(parameters)); }
	package _pSDL_HapticRunEffect _SDL_HapticRunEffect;
	extern(C) int SDL_HapticRunEffect(SDL_Haptic* haptic, int effect, uint iterations){ return _SDL_HapticRunEffect(__traits(parameters)); }
	package _pSDL_HapticStopEffect _SDL_HapticStopEffect;
	extern(C) int SDL_HapticStopEffect(SDL_Haptic* haptic, int effect){ return _SDL_HapticStopEffect(__traits(parameters)); }
	package _pSDL_HapticDestroyEffect _SDL_HapticDestroyEffect;
	extern(C) int SDL_HapticDestroyEffect(SDL_Haptic* haptic, int effect){ return _SDL_HapticDestroyEffect(__traits(parameters)); }
	package _pSDL_HapticGetEffectStatus _SDL_HapticGetEffectStatus;
	extern(C) int SDL_HapticGetEffectStatus(SDL_Haptic* haptic, int effect){ return _SDL_HapticGetEffectStatus(__traits(parameters)); }
	package _pSDL_HapticSetGain _SDL_HapticSetGain;
	extern(C) int SDL_HapticSetGain(SDL_Haptic* haptic, int gain){ return _SDL_HapticSetGain(__traits(parameters)); }
	package _pSDL_HapticSetAutocenter _SDL_HapticSetAutocenter;
	extern(C) int SDL_HapticSetAutocenter(SDL_Haptic* haptic, int autocentre){ return _SDL_HapticSetAutocenter(__traits(parameters)); }
	package _pSDL_HapticPause _SDL_HapticPause;
	extern(C) int SDL_HapticPause(SDL_Haptic* haptic){ return _SDL_HapticPause(__traits(parameters)); }
	package _pSDL_HapticUnpause _SDL_HapticUnpause;
	extern(C) int SDL_HapticUnpause(SDL_Haptic* haptic){ return _SDL_HapticUnpause(__traits(parameters)); }
	package _pSDL_HapticStopAll _SDL_HapticStopAll;
	extern(C) int SDL_HapticStopAll(SDL_Haptic* haptic){ return _SDL_HapticStopAll(__traits(parameters)); }
	package _pSDL_HapticRumbleSupported _SDL_HapticRumbleSupported;
	extern(C) int SDL_HapticRumbleSupported(SDL_Haptic* haptic){ return _SDL_HapticRumbleSupported(__traits(parameters)); }
	package _pSDL_HapticRumbleInit _SDL_HapticRumbleInit;
	extern(C) int SDL_HapticRumbleInit(SDL_Haptic* haptic){ return _SDL_HapticRumbleInit(__traits(parameters)); }
	package _pSDL_HapticRumblePlay _SDL_HapticRumblePlay;
	extern(C) int SDL_HapticRumblePlay(SDL_Haptic* haptic, float strength, uint length){ return _SDL_HapticRumblePlay(__traits(parameters)); }
	package _pSDL_HapticRumbleStop _SDL_HapticRumbleStop;
	extern(C) int SDL_HapticRumbleStop(SDL_Haptic* haptic){ return _SDL_HapticRumbleStop(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_NumHaptics, here.SDL_NumHaptics.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticName, here.SDL_HapticName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticOpen, here.SDL_HapticOpen.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticOpened, here.SDL_HapticOpened.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticIndex, here.SDL_HapticIndex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_MouseIsHaptic, here.SDL_MouseIsHaptic.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticOpenFromMouse, here.SDL_HapticOpenFromMouse.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_JoystickIsHaptic, here.SDL_JoystickIsHaptic.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticOpenFromJoystick, here.SDL_HapticOpenFromJoystick.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticClose, here.SDL_HapticClose.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticNumEffects, here.SDL_HapticNumEffects.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticNumEffectsPlaying, here.SDL_HapticNumEffectsPlaying.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticQuery, here.SDL_HapticQuery.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticNumAxes, here.SDL_HapticNumAxes.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticEffectSupported, here.SDL_HapticEffectSupported.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticNewEffect, here.SDL_HapticNewEffect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticUpdateEffect, here.SDL_HapticUpdateEffect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticRunEffect, here.SDL_HapticRunEffect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticStopEffect, here.SDL_HapticStopEffect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticDestroyEffect, here.SDL_HapticDestroyEffect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticGetEffectStatus, here.SDL_HapticGetEffectStatus.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticSetGain, here.SDL_HapticSetGain.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticSetAutocenter, here.SDL_HapticSetAutocenter.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticPause, here.SDL_HapticPause.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticUnpause, here.SDL_HapticUnpause.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticStopAll, here.SDL_HapticStopAll.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticRumbleSupported, here.SDL_HapticRumbleSupported.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticRumbleInit, here.SDL_HapticRumbleInit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticRumblePlay, here.SDL_HapticRumblePlay.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_HapticRumbleStop, here.SDL_HapticRumbleStop.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/hints.d(278,1)
private nothrow @nogc{
	alias _pSDL_SetHintWithPriority = extern(C) SDL_bool function(const(char)* name, const(char)* value, SDL_HintPriority priority);
	alias _pSDL_SetHint = extern(C) SDL_bool function(const(char)* name, const(char)* value);
	alias _pSDL_GetHint = extern(C) const(char)* function(const(char)* name);
	alias _pSDL_AddHintCallback = extern(C) void function(const(char)* name, SDL_HintCallback callback, void* userData);
	alias _pSDL_DelHintCallback = extern(C) void function(const(char)* name, SDL_HintCallback callback, void* userData);
	alias _pSDL_ClearHints = extern(C) void function();
}
__gshared nothrow @nogc{
	package _pSDL_SetHintWithPriority _SDL_SetHintWithPriority;
	extern(C) SDL_bool SDL_SetHintWithPriority(const(char)* name, const(char)* value, SDL_HintPriority priority){ return _SDL_SetHintWithPriority(__traits(parameters)); }
	package _pSDL_SetHint _SDL_SetHint;
	extern(C) SDL_bool SDL_SetHint(const(char)* name, const(char)* value){ return _SDL_SetHint(__traits(parameters)); }
	package _pSDL_GetHint _SDL_GetHint;
	extern(C) const(char)* SDL_GetHint(const(char)* name){ return _SDL_GetHint(__traits(parameters)); }
	package _pSDL_AddHintCallback _SDL_AddHintCallback;
	extern(C) void SDL_AddHintCallback(const(char)* name, SDL_HintCallback callback, void* userData){ _SDL_AddHintCallback(__traits(parameters)); }
	package _pSDL_DelHintCallback _SDL_DelHintCallback;
	extern(C) void SDL_DelHintCallback(const(char)* name, SDL_HintCallback callback, void* userData){ _SDL_DelHintCallback(__traits(parameters)); }
	package _pSDL_ClearHints _SDL_ClearHints;
	extern(C) void SDL_ClearHints(){ _SDL_ClearHints(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_SetHintWithPriority, here.SDL_SetHintWithPriority.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetHint, here.SDL_SetHint.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetHint, here.SDL_GetHint.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AddHintCallback, here.SDL_AddHintCallback.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DelHintCallback, here.SDL_DelHintCallback.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ClearHints, here.SDL_ClearHints.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/loadso.d(13,1)
private nothrow @nogc{
	alias _pSDL_LoadObject = extern(C) void* function(const(char)* soFile);
	alias _pSDL_LoadFunction = extern(C) void* function(void* handle,const(char*) name);
	alias _pSDL_UnloadObject = extern(C) void function(void* handle);
}
__gshared nothrow @nogc{
	package _pSDL_LoadObject _SDL_LoadObject;
	extern(C) void* SDL_LoadObject(const(char)* soFile){ return _SDL_LoadObject(__traits(parameters)); }
	package _pSDL_LoadFunction _SDL_LoadFunction;
	extern(C) void* SDL_LoadFunction(void* handle,const(char*) name){ return _SDL_LoadFunction(__traits(parameters)); }
	package _pSDL_UnloadObject _SDL_UnloadObject;
	extern(C) void SDL_UnloadObject(void* handle){ _SDL_UnloadObject(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_LoadObject, here.SDL_LoadObject.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LoadFunction, here.SDL_LoadFunction.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UnloadObject, here.SDL_UnloadObject.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/locale.d(19,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/log.d(55,1)
private nothrow @nogc{
	alias _pSDL_LogSetAllPriority = extern(C) void function(SDL_LogPriority priority);
	alias _pSDL_LogSetPriority = extern(C) void function(int category, SDL_LogPriority priority);
	alias _pSDL_LogGetPriority = extern(C) SDL_LogPriority function(int category);
	alias _pSDL_LogResetPriorities = extern(C) void function();
	alias _pSDL_Log = extern(C) void function(const(char)* fmt, ...);
	alias _pSDL_LogVerbose = extern(C) void function(int category, const(char)* fmt, ...);
	alias _pSDL_LogDebug = extern(C) void function(int category, const(char)* fmt, ...);
	alias _pSDL_LogInfo = extern(C) void function(int category, const(char)* fmt, ...);
	alias _pSDL_LogWarn = extern(C) void function(int category, const(char)* fmt, ...);
	alias _pSDL_LogError = extern(C) void function(int category, const(char)* fmt, ...);
	alias _pSDL_LogCritical = extern(C) void function(int category, const(char)* fmt, ...);
	alias _pSDL_LogMessage = extern(C) void function(int category, SDL_LogPriority priority, const(char)* fmt, ...);
	alias _pSDL_LogMessageV = extern(C) void function(int category, SDL_LogPriority priority, const(char)* fmt, va_list ap);
	alias _pSDL_LogGetOutputFunction = extern(C) void function(SDL_LogOutputFunction callback, void** userData);
	alias _pSDL_LogSetOutputFunction = extern(C) void function(SDL_LogOutputFunction callback, void* userData);
}
__gshared nothrow @nogc{
	package _pSDL_LogSetAllPriority _SDL_LogSetAllPriority;
	extern(C) void SDL_LogSetAllPriority(SDL_LogPriority priority){ _SDL_LogSetAllPriority(__traits(parameters)); }
	package _pSDL_LogSetPriority _SDL_LogSetPriority;
	extern(C) void SDL_LogSetPriority(int category, SDL_LogPriority priority){ _SDL_LogSetPriority(__traits(parameters)); }
	package _pSDL_LogGetPriority _SDL_LogGetPriority;
	extern(C) SDL_LogPriority SDL_LogGetPriority(int category){ return _SDL_LogGetPriority(__traits(parameters)); }
	package _pSDL_LogResetPriorities _SDL_LogResetPriorities;
	extern(C) void SDL_LogResetPriorities(){ _SDL_LogResetPriorities(__traits(parameters)); }
	_pSDL_Log SDL_Log;
	_pSDL_LogVerbose SDL_LogVerbose;
	_pSDL_LogDebug SDL_LogDebug;
	_pSDL_LogInfo SDL_LogInfo;
	_pSDL_LogWarn SDL_LogWarn;
	_pSDL_LogError SDL_LogError;
	_pSDL_LogCritical SDL_LogCritical;
	_pSDL_LogMessage SDL_LogMessage;
	package _pSDL_LogMessageV _SDL_LogMessageV;
	extern(C) void SDL_LogMessageV(int category, SDL_LogPriority priority, const(char)* fmt, va_list ap){ _SDL_LogMessageV(__traits(parameters)); }
	package _pSDL_LogGetOutputFunction _SDL_LogGetOutputFunction;
	extern(C) void SDL_LogGetOutputFunction(SDL_LogOutputFunction callback, void** userData){ _SDL_LogGetOutputFunction(__traits(parameters)); }
	package _pSDL_LogSetOutputFunction _SDL_LogSetOutputFunction;
	extern(C) void SDL_LogSetOutputFunction(SDL_LogOutputFunction callback, void* userData){ _SDL_LogSetOutputFunction(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_LogSetAllPriority, here.SDL_LogSetAllPriority.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LogSetPriority, here.SDL_LogSetPriority.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LogGetPriority, here.SDL_LogGetPriority.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LogResetPriorities, here.SDL_LogResetPriorities.mangleof);
	lib.bindSymbol(cast(void**)&SDL_Log, "SDL_Log");
	lib.bindSymbol(cast(void**)&SDL_LogVerbose, "SDL_LogVerbose");
	lib.bindSymbol(cast(void**)&SDL_LogDebug, "SDL_LogDebug");
	lib.bindSymbol(cast(void**)&SDL_LogInfo, "SDL_LogInfo");
	lib.bindSymbol(cast(void**)&SDL_LogWarn, "SDL_LogWarn");
	lib.bindSymbol(cast(void**)&SDL_LogError, "SDL_LogError");
	lib.bindSymbol(cast(void**)&SDL_LogCritical, "SDL_LogCritical");
	lib.bindSymbol(cast(void**)&SDL_LogMessage, "SDL_LogMessage");
	lib.bindSymbol(cast(void**)&_SDL_LogMessageV, here.SDL_LogMessageV.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LogGetOutputFunction, here.SDL_LogGetOutputFunction.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LogSetOutputFunction, here.SDL_LogSetOutputFunction.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/messagebox.d(79,1)
private nothrow @nogc{
	alias _pSDL_ShowMessageBox = extern(C) int function(const(SDL_MessageBoxData)* messageBoxData, int* buttonID);
	alias _pSDL_ShowSimpleMessageBox = extern(C) int function(SDL_MessageBoxFlags flags, const(char)* title, const(char)* messsage, SDL_Window* window);
}
__gshared nothrow @nogc{
	package _pSDL_ShowMessageBox _SDL_ShowMessageBox;
	extern(C) int SDL_ShowMessageBox(const(SDL_MessageBoxData)* messageBoxData, int* buttonID){ return _SDL_ShowMessageBox(__traits(parameters)); }
	package _pSDL_ShowSimpleMessageBox _SDL_ShowSimpleMessageBox;
	extern(C) int SDL_ShowSimpleMessageBox(SDL_MessageBoxFlags flags, const(char)* title, const(char)* messsage, SDL_Window* window){ return _SDL_ShowSimpleMessageBox(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_ShowMessageBox, here.SDL_ShowMessageBox.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ShowSimpleMessageBox, here.SDL_ShowSimpleMessageBox.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/metal.d(16,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/misc.d(13,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/mouse.d(63,1)
private nothrow @nogc{
	alias _pSDL_GetMouseFocus = extern(C) SDL_Window* function();
	alias _pSDL_GetMouseState = extern(C) uint function(int* x, int* y);
	alias _pSDL_GetRelativeMouseState = extern(C) uint function(int* x, int* y);
	alias _pSDL_WarpMouseInWindow = extern(C) void function(SDL_Window* window, int x, int y);
	alias _pSDL_SetRelativeMouseMode = extern(C) int function(SDL_bool enabled);
	alias _pSDL_GetRelativeMouseMode = extern(C) SDL_bool function();
	alias _pSDL_CreateCursor = extern(C) SDL_Cursor* function(const(ubyte)* data, const(ubyte)* mask, int w, int h, int hotX, int hotY);
	alias _pSDL_CreateColorCursor = extern(C) SDL_Cursor* function(SDL_Surface* surface, int hotX, int hotY);
	alias _pSDL_CreateSystemCursor = extern(C) SDL_Cursor* function(SDL_SystemCursor id);
	alias _pSDL_SetCursor = extern(C) void function(SDL_Cursor* cursor);
	alias _pSDL_GetCursor = extern(C) SDL_Cursor* function();
	alias _pSDL_GetDefaultCursor = extern(C) SDL_Cursor* function();
	alias _pSDL_FreeCursor = extern(C) void function(SDL_Cursor* cursor);
	alias _pSDL_ShowCursor = extern(C) int function(int toggle);
}
__gshared nothrow @nogc{
	package _pSDL_GetMouseFocus _SDL_GetMouseFocus;
	extern(C) SDL_Window* SDL_GetMouseFocus(){ return _SDL_GetMouseFocus(__traits(parameters)); }
	package _pSDL_GetMouseState _SDL_GetMouseState;
	extern(C) uint SDL_GetMouseState(int* x, int* y){ return _SDL_GetMouseState(__traits(parameters)); }
	package _pSDL_GetRelativeMouseState _SDL_GetRelativeMouseState;
	extern(C) uint SDL_GetRelativeMouseState(int* x, int* y){ return _SDL_GetRelativeMouseState(__traits(parameters)); }
	package _pSDL_WarpMouseInWindow _SDL_WarpMouseInWindow;
	extern(C) void SDL_WarpMouseInWindow(SDL_Window* window, int x, int y){ _SDL_WarpMouseInWindow(__traits(parameters)); }
	package _pSDL_SetRelativeMouseMode _SDL_SetRelativeMouseMode;
	extern(C) int SDL_SetRelativeMouseMode(SDL_bool enabled){ return _SDL_SetRelativeMouseMode(__traits(parameters)); }
	package _pSDL_GetRelativeMouseMode _SDL_GetRelativeMouseMode;
	extern(C) SDL_bool SDL_GetRelativeMouseMode(){ return _SDL_GetRelativeMouseMode(__traits(parameters)); }
	package _pSDL_CreateCursor _SDL_CreateCursor;
	extern(C) SDL_Cursor* SDL_CreateCursor(const(ubyte)* data, const(ubyte)* mask, int w, int h, int hotX, int hotY){ return _SDL_CreateCursor(__traits(parameters)); }
	package _pSDL_CreateColorCursor _SDL_CreateColorCursor;
	extern(C) SDL_Cursor* SDL_CreateColorCursor(SDL_Surface* surface, int hotX, int hotY){ return _SDL_CreateColorCursor(__traits(parameters)); }
	package _pSDL_CreateSystemCursor _SDL_CreateSystemCursor;
	extern(C) SDL_Cursor* SDL_CreateSystemCursor(SDL_SystemCursor id){ return _SDL_CreateSystemCursor(__traits(parameters)); }
	package _pSDL_SetCursor _SDL_SetCursor;
	extern(C) void SDL_SetCursor(SDL_Cursor* cursor){ _SDL_SetCursor(__traits(parameters)); }
	package _pSDL_GetCursor _SDL_GetCursor;
	extern(C) SDL_Cursor* SDL_GetCursor(){ return _SDL_GetCursor(__traits(parameters)); }
	package _pSDL_GetDefaultCursor _SDL_GetDefaultCursor;
	extern(C) SDL_Cursor* SDL_GetDefaultCursor(){ return _SDL_GetDefaultCursor(__traits(parameters)); }
	package _pSDL_FreeCursor _SDL_FreeCursor;
	extern(C) void SDL_FreeCursor(SDL_Cursor* cursor){ _SDL_FreeCursor(__traits(parameters)); }
	package _pSDL_ShowCursor _SDL_ShowCursor;
	extern(C) int SDL_ShowCursor(int toggle){ return _SDL_ShowCursor(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetMouseFocus, here.SDL_GetMouseFocus.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetMouseState, here.SDL_GetMouseState.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRelativeMouseState, here.SDL_GetRelativeMouseState.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WarpMouseInWindow, here.SDL_WarpMouseInWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetRelativeMouseMode, here.SDL_SetRelativeMouseMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRelativeMouseMode, here.SDL_GetRelativeMouseMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateCursor, here.SDL_CreateCursor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateColorCursor, here.SDL_CreateColorCursor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateSystemCursor, here.SDL_CreateSystemCursor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetCursor, here.SDL_SetCursor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetCursor, here.SDL_GetCursor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetDefaultCursor, here.SDL_GetDefaultCursor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_FreeCursor, here.SDL_FreeCursor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ShowCursor, here.SDL_ShowCursor.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/mutex.d(24,1)
private nothrow @nogc{
	alias _pSDL_CreateMutex = extern(C) SDL_mutex* function();
	alias _pSDL_LockMutex = extern(C) int function(SDL_mutex* mutex);
	alias _pSDL_TryLockMutex = extern(C) int function(SDL_mutex* mutex);
	alias _pSDL_UnlockMutex = extern(C) int function(SDL_mutex* mutex);
	alias _pSDL_DestroyMutex = extern(C) void function(SDL_mutex* mutex);
	alias _pSDL_CreateSemaphore = extern(C) SDL_semaphore* function(uint initialValue);
	alias _pSDL_DestroySemaphore = extern(C) void function(SDL_semaphore* sem);
	alias _pSDL_SemWait = extern(C) int function(SDL_semaphore* sem);
	alias _pSDL_SemTryWait = extern(C) int function(SDL_semaphore* sem);
	alias _pSDL_SemWaitTimeout = extern(C) int function(SDL_semaphore* sem, uint timeout);
	alias _pSDL_SemPost = extern(C) int function(SDL_semaphore* sem);
	alias _pSDL_SemValue = extern(C) uint function(SDL_semaphore* sem);
	alias _pSDL_CreateCond = extern(C) SDL_cond* function();
	alias _pSDL_DestroyCond = extern(C) void function(SDL_cond* cond);
	alias _pSDL_CondSignal = extern(C) int function(SDL_cond* cond);
	alias _pSDL_CondBroadcast = extern(C) int function(SDL_cond* cond);
	alias _pSDL_CondWait = extern(C) int function(SDL_cond* cond, SDL_mutex*);
	alias _pSDL_CondWaitTimeout = extern(C) int function(SDL_cond* cond, SDL_mutex* mutex, uint ms);
}
__gshared nothrow @nogc{
	package _pSDL_CreateMutex _SDL_CreateMutex;
	extern(C) SDL_mutex* SDL_CreateMutex(){ return _SDL_CreateMutex(__traits(parameters)); }
	package _pSDL_LockMutex _SDL_LockMutex;
	extern(C) int SDL_LockMutex(SDL_mutex* mutex){ return _SDL_LockMutex(__traits(parameters)); }
	package _pSDL_TryLockMutex _SDL_TryLockMutex;
	extern(C) int SDL_TryLockMutex(SDL_mutex* mutex){ return _SDL_TryLockMutex(__traits(parameters)); }
	package _pSDL_UnlockMutex _SDL_UnlockMutex;
	extern(C) int SDL_UnlockMutex(SDL_mutex* mutex){ return _SDL_UnlockMutex(__traits(parameters)); }
	package _pSDL_DestroyMutex _SDL_DestroyMutex;
	extern(C) void SDL_DestroyMutex(SDL_mutex* mutex){ _SDL_DestroyMutex(__traits(parameters)); }
	package _pSDL_CreateSemaphore _SDL_CreateSemaphore;
	extern(C) SDL_semaphore* SDL_CreateSemaphore(uint initialValue){ return _SDL_CreateSemaphore(__traits(parameters)); }
	package _pSDL_DestroySemaphore _SDL_DestroySemaphore;
	extern(C) void SDL_DestroySemaphore(SDL_semaphore* sem){ _SDL_DestroySemaphore(__traits(parameters)); }
	package _pSDL_SemWait _SDL_SemWait;
	extern(C) int SDL_SemWait(SDL_semaphore* sem){ return _SDL_SemWait(__traits(parameters)); }
	package _pSDL_SemTryWait _SDL_SemTryWait;
	extern(C) int SDL_SemTryWait(SDL_semaphore* sem){ return _SDL_SemTryWait(__traits(parameters)); }
	package _pSDL_SemWaitTimeout _SDL_SemWaitTimeout;
	extern(C) int SDL_SemWaitTimeout(SDL_semaphore* sem, uint timeout){ return _SDL_SemWaitTimeout(__traits(parameters)); }
	package _pSDL_SemPost _SDL_SemPost;
	extern(C) int SDL_SemPost(SDL_semaphore* sem){ return _SDL_SemPost(__traits(parameters)); }
	package _pSDL_SemValue _SDL_SemValue;
	extern(C) uint SDL_SemValue(SDL_semaphore* sem){ return _SDL_SemValue(__traits(parameters)); }
	package _pSDL_CreateCond _SDL_CreateCond;
	extern(C) SDL_cond* SDL_CreateCond(){ return _SDL_CreateCond(__traits(parameters)); }
	package _pSDL_DestroyCond _SDL_DestroyCond;
	extern(C) void SDL_DestroyCond(SDL_cond* cond){ _SDL_DestroyCond(__traits(parameters)); }
	package _pSDL_CondSignal _SDL_CondSignal;
	extern(C) int SDL_CondSignal(SDL_cond* cond){ return _SDL_CondSignal(__traits(parameters)); }
	package _pSDL_CondBroadcast _SDL_CondBroadcast;
	extern(C) int SDL_CondBroadcast(SDL_cond* cond){ return _SDL_CondBroadcast(__traits(parameters)); }
	package _pSDL_CondWait _SDL_CondWait;
	extern(C) int SDL_CondWait(SDL_cond* cond, SDL_mutex*){ return _SDL_CondWait(__traits(parameters)); }
	package _pSDL_CondWaitTimeout _SDL_CondWaitTimeout;
	extern(C) int SDL_CondWaitTimeout(SDL_cond* cond, SDL_mutex* mutex, uint ms){ return _SDL_CondWaitTimeout(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_CreateMutex, here.SDL_CreateMutex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LockMutex, here.SDL_LockMutex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_TryLockMutex, here.SDL_TryLockMutex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UnlockMutex, here.SDL_UnlockMutex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DestroyMutex, here.SDL_DestroyMutex.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateSemaphore, here.SDL_CreateSemaphore.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DestroySemaphore, here.SDL_DestroySemaphore.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SemWait, here.SDL_SemWait.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SemTryWait, here.SDL_SemTryWait.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SemWaitTimeout, here.SDL_SemWaitTimeout.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SemPost, here.SDL_SemPost.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SemValue, here.SDL_SemValue.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateCond, here.SDL_CreateCond.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DestroyCond, here.SDL_DestroyCond.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CondSignal, here.SDL_CondSignal.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CondBroadcast, here.SDL_CondBroadcast.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CondWait, here.SDL_CondWait.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CondWaitTimeout, here.SDL_CondWaitTimeout.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/platform.d(13,1)
private nothrow @nogc{
	alias _pSDL_GetPlatform = extern(C) const(char)* function();
}
__gshared nothrow @nogc{
	package _pSDL_GetPlatform _SDL_GetPlatform;
	extern(C) const(char)* SDL_GetPlatform(){ return _SDL_GetPlatform(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetPlatform, here.SDL_GetPlatform.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/power.d(22,1)
private nothrow @nogc{
	alias _pSDL_GetPowerInfo = extern(C) SDL_PowerState function(int* seconds, int* percent);
}
__gshared nothrow @nogc{
	package _pSDL_GetPowerInfo _SDL_GetPowerInfo;
	extern(C) SDL_PowerState SDL_GetPowerInfo(int* seconds, int* percent){ return _SDL_GetPowerInfo(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetPowerInfo, here.SDL_GetPowerInfo.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/render.d(82,1)
private nothrow @nogc{
	alias _pSDL_GetNumRenderDrivers = extern(C) int function();
	alias _pSDL_GetRenderDriverInfo = extern(C) int function(int index, SDL_RendererInfo* info);
	alias _pSDL_CreateWindowAndRenderer = extern(C) int function(int width, int height, uint windowFlags, SDL_Window** window, SDL_Renderer** renderer);
	alias _pSDL_CreateRenderer = extern(C) SDL_Renderer* function(SDL_Window* window, int index, SDL_RendererFlags flags);
	alias _pSDL_CreateSoftwareRenderer = extern(C) SDL_Renderer* function(SDL_Surface* surface);
	alias _pSDL_GetRenderer = extern(C) SDL_Renderer* function(SDL_Window* window);
	alias _pSDL_GetRendererInfo = extern(C) int function(SDL_Renderer* renderer, SDL_RendererInfo* info);
	alias _pSDL_GetRendererOutputSize = extern(C) int function(SDL_Renderer* renderer, int* w, int* h);
	alias _pSDL_CreateTexture = extern(C) SDL_Texture* function(SDL_Renderer* renderer, uint format, SDL_TextureAccess access, int w, int h);
	alias _pSDL_CreateTextureFromSurface = extern(C) SDL_Texture* function(SDL_Renderer* renderer, SDL_Surface* surface);
	alias _pSDL_QueryTexture = extern(C) int function(SDL_Texture* texture, uint* format, SDL_TextureAccess* access, int* w, int* h);
	alias _pSDL_SetTextureColorMod = extern(C) int function(SDL_Texture* texture, ubyte r, ubyte g, ubyte b);
	alias _pSDL_GetTextureColorMod = extern(C) int function(SDL_Texture* texture, ubyte* r, ubyte* g, ubyte* b);
	alias _pSDL_SetTextureAlphaMod = extern(C) int function(SDL_Texture* texture, ubyte alpha);
	alias _pSDL_GetTextureAlphaMod = extern(C) int function(SDL_Texture* texture, ubyte* alpha);
	alias _pSDL_SetTextureBlendMode = extern(C) int function(SDL_Texture* texture, SDL_BlendMode blendMode);
	alias _pSDL_GetTextureBlendMode = extern(C) int function(SDL_Texture* texture, SDL_BlendMode* blendMode);
	alias _pSDL_UpdateTexture = extern(C) int function(SDL_Texture* texture, const(SDL_Rect)* rect, const(void)* pixels, int pitch);
	alias _pSDL_LockTexture = extern(C) int function(SDL_Texture* texture, const(SDL_Rect)* rect, void** pixels, int* pitch);
	alias _pSDL_UnlockTexture = extern(C) void function(SDL_Texture* texture);
	alias _pSDL_RenderTargetSupported = extern(C) SDL_bool function(SDL_Renderer* renderer);
	alias _pSDL_SetRenderTarget = extern(C) int function(SDL_Renderer* renderer, SDL_Texture* texture);
	alias _pSDL_GetRenderTarget = extern(C) SDL_Texture* function(SDL_Renderer* renderer);
	alias _pSDL_RenderSetClipRect = extern(C) int function(SDL_Renderer* renderer, const(SDL_Rect)* rect);
	alias _pSDL_RenderGetClipRect = extern(C) void function(SDL_Renderer* renderer, SDL_Rect* rect);
	alias _pSDL_RenderSetLogicalSize = extern(C) int function(SDL_Renderer* renderer, int w, int h);
	alias _pSDL_RenderGetLogicalSize = extern(C) void function(SDL_Renderer* renderer, int* w, int* h);
	alias _pSDL_RenderSetViewport = extern(C) int function(SDL_Renderer* renderer, const(SDL_Rect)* rect);
	alias _pSDL_RenderGetViewport = extern(C) void function(SDL_Renderer* renderer, SDL_Rect* rect);
	alias _pSDL_RenderSetScale = extern(C) int function(SDL_Renderer* renderer, float scaleX, float scaleY);
	alias _pSDL_RenderGetScale = extern(C) int function(SDL_Renderer* renderer, float* scaleX, float* scaleY);
	alias _pSDL_SetRenderDrawColor = extern(C) int function(SDL_Renderer* renderer, ubyte r, ubyte g, ubyte b, ubyte a);
	alias _pSDL_GetRenderDrawColor = extern(C) int function(SDL_Renderer* renderer, ubyte* r, ubyte* g, ubyte* b, ubyte* a);
	alias _pSDL_SetRenderDrawBlendMode = extern(C) int function(SDL_Renderer* renderer, SDL_BlendMode blendMode);
	alias _pSDL_GetRenderDrawBlendMode = extern(C) int function(SDL_Renderer* renderer, SDL_BlendMode* blendMode);
	alias _pSDL_RenderClear = extern(C) int function(SDL_Renderer* renderer);
	alias _pSDL_RenderDrawPoint = extern(C) int function(SDL_Renderer* renderer, int x, int y);
	alias _pSDL_RenderDrawPoints = extern(C) int function(SDL_Renderer* renderer, const(SDL_Point)* points, int count);
	alias _pSDL_RenderDrawLine = extern(C) int function(SDL_Renderer* renderer, int x1, int y1, int x2, int y2);
	alias _pSDL_RenderDrawLines = extern(C) int function(SDL_Renderer* renderer, const(SDL_Point)* points, int count);
	alias _pSDL_RenderDrawRect = extern(C) int function(SDL_Renderer* renderer, const(SDL_Rect)* rect);
	alias _pSDL_RenderDrawRects = extern(C) int function(SDL_Renderer* renderer, const(SDL_Rect)* rects, int count);
	alias _pSDL_RenderFillRect = extern(C) int function(SDL_Renderer* renderer, const(SDL_Rect)* rect);
	alias _pSDL_RenderFillRects = extern(C) int function(SDL_Renderer* renderer, const(SDL_Rect)* rects, int count);
	alias _pSDL_RenderCopy = extern(C) int function(SDL_Renderer* renderer, SDL_Texture* texture, const(SDL_Rect)* srcRect, const(SDL_Rect)* dstRect);
	alias _pSDL_RenderCopyEx = extern(C) int function(SDL_Renderer* renderer, SDL_Texture* texture, const(SDL_Rect)* srcRect, const(SDL_Rect)* dstRect, const(double) angle, const(SDL_Point)* centre, const(SDL_RendererFlip) flip);
	alias _pSDL_RenderReadPixels = extern(C) int function(SDL_Renderer* renderer, const(SDL_Rect)* rect, uint, void*, int);
	alias _pSDL_RenderPresent = extern(C) void function(SDL_Renderer* renderer);
	alias _pSDL_DestroyTexture = extern(C) void function(SDL_Texture* texture);
	alias _pSDL_DestroyRenderer = extern(C) void function(SDL_Renderer* renderer);
	alias _pSDL_GL_BindTexture = extern(C) int function(SDL_Texture* texture, float* texw, float* texh);
	alias _pSDL_GL_UnbindTexture = extern(C) int function(SDL_Texture* texture);
}
__gshared nothrow @nogc{
	package _pSDL_GetNumRenderDrivers _SDL_GetNumRenderDrivers;
	extern(C) int SDL_GetNumRenderDrivers(){ return _SDL_GetNumRenderDrivers(__traits(parameters)); }
	package _pSDL_GetRenderDriverInfo _SDL_GetRenderDriverInfo;
	extern(C) int SDL_GetRenderDriverInfo(int index, SDL_RendererInfo* info){ return _SDL_GetRenderDriverInfo(__traits(parameters)); }
	package _pSDL_CreateWindowAndRenderer _SDL_CreateWindowAndRenderer;
	extern(C) int SDL_CreateWindowAndRenderer(int width, int height, uint windowFlags, SDL_Window** window, SDL_Renderer** renderer){ return _SDL_CreateWindowAndRenderer(__traits(parameters)); }
	package _pSDL_CreateRenderer _SDL_CreateRenderer;
	extern(C) SDL_Renderer* SDL_CreateRenderer(SDL_Window* window, int index, SDL_RendererFlags flags){ return _SDL_CreateRenderer(__traits(parameters)); }
	package _pSDL_CreateSoftwareRenderer _SDL_CreateSoftwareRenderer;
	extern(C) SDL_Renderer* SDL_CreateSoftwareRenderer(SDL_Surface* surface){ return _SDL_CreateSoftwareRenderer(__traits(parameters)); }
	package _pSDL_GetRenderer _SDL_GetRenderer;
	extern(C) SDL_Renderer* SDL_GetRenderer(SDL_Window* window){ return _SDL_GetRenderer(__traits(parameters)); }
	package _pSDL_GetRendererInfo _SDL_GetRendererInfo;
	extern(C) int SDL_GetRendererInfo(SDL_Renderer* renderer, SDL_RendererInfo* info){ return _SDL_GetRendererInfo(__traits(parameters)); }
	package _pSDL_GetRendererOutputSize _SDL_GetRendererOutputSize;
	extern(C) int SDL_GetRendererOutputSize(SDL_Renderer* renderer, int* w, int* h){ return _SDL_GetRendererOutputSize(__traits(parameters)); }
	package _pSDL_CreateTexture _SDL_CreateTexture;
	extern(C) SDL_Texture* SDL_CreateTexture(SDL_Renderer* renderer, uint format, SDL_TextureAccess access, int w, int h){ return _SDL_CreateTexture(__traits(parameters)); }
	package _pSDL_CreateTextureFromSurface _SDL_CreateTextureFromSurface;
	extern(C) SDL_Texture* SDL_CreateTextureFromSurface(SDL_Renderer* renderer, SDL_Surface* surface){ return _SDL_CreateTextureFromSurface(__traits(parameters)); }
	package _pSDL_QueryTexture _SDL_QueryTexture;
	extern(C) int SDL_QueryTexture(SDL_Texture* texture, uint* format, SDL_TextureAccess* access, int* w, int* h){ return _SDL_QueryTexture(__traits(parameters)); }
	package _pSDL_SetTextureColorMod _SDL_SetTextureColorMod;
	extern(C) int SDL_SetTextureColorMod(SDL_Texture* texture, ubyte r, ubyte g, ubyte b){ return _SDL_SetTextureColorMod(__traits(parameters)); }
	package _pSDL_GetTextureColorMod _SDL_GetTextureColorMod;
	extern(C) int SDL_GetTextureColorMod(SDL_Texture* texture, ubyte* r, ubyte* g, ubyte* b){ return _SDL_GetTextureColorMod(__traits(parameters)); }
	package _pSDL_SetTextureAlphaMod _SDL_SetTextureAlphaMod;
	extern(C) int SDL_SetTextureAlphaMod(SDL_Texture* texture, ubyte alpha){ return _SDL_SetTextureAlphaMod(__traits(parameters)); }
	package _pSDL_GetTextureAlphaMod _SDL_GetTextureAlphaMod;
	extern(C) int SDL_GetTextureAlphaMod(SDL_Texture* texture, ubyte* alpha){ return _SDL_GetTextureAlphaMod(__traits(parameters)); }
	package _pSDL_SetTextureBlendMode _SDL_SetTextureBlendMode;
	extern(C) int SDL_SetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode blendMode){ return _SDL_SetTextureBlendMode(__traits(parameters)); }
	package _pSDL_GetTextureBlendMode _SDL_GetTextureBlendMode;
	extern(C) int SDL_GetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode* blendMode){ return _SDL_GetTextureBlendMode(__traits(parameters)); }
	package _pSDL_UpdateTexture _SDL_UpdateTexture;
	extern(C) int SDL_UpdateTexture(SDL_Texture* texture, const(SDL_Rect)* rect, const(void)* pixels, int pitch){ return _SDL_UpdateTexture(__traits(parameters)); }
	package _pSDL_LockTexture _SDL_LockTexture;
	extern(C) int SDL_LockTexture(SDL_Texture* texture, const(SDL_Rect)* rect, void** pixels, int* pitch){ return _SDL_LockTexture(__traits(parameters)); }
	package _pSDL_UnlockTexture _SDL_UnlockTexture;
	extern(C) void SDL_UnlockTexture(SDL_Texture* texture){ _SDL_UnlockTexture(__traits(parameters)); }
	package _pSDL_RenderTargetSupported _SDL_RenderTargetSupported;
	extern(C) SDL_bool SDL_RenderTargetSupported(SDL_Renderer* renderer){ return _SDL_RenderTargetSupported(__traits(parameters)); }
	package _pSDL_SetRenderTarget _SDL_SetRenderTarget;
	extern(C) int SDL_SetRenderTarget(SDL_Renderer* renderer, SDL_Texture* texture){ return _SDL_SetRenderTarget(__traits(parameters)); }
	package _pSDL_GetRenderTarget _SDL_GetRenderTarget;
	extern(C) SDL_Texture* SDL_GetRenderTarget(SDL_Renderer* renderer){ return _SDL_GetRenderTarget(__traits(parameters)); }
	package _pSDL_RenderSetClipRect _SDL_RenderSetClipRect;
	extern(C) int SDL_RenderSetClipRect(SDL_Renderer* renderer, const(SDL_Rect)* rect){ return _SDL_RenderSetClipRect(__traits(parameters)); }
	package _pSDL_RenderGetClipRect _SDL_RenderGetClipRect;
	extern(C) void SDL_RenderGetClipRect(SDL_Renderer* renderer, SDL_Rect* rect){ _SDL_RenderGetClipRect(__traits(parameters)); }
	package _pSDL_RenderSetLogicalSize _SDL_RenderSetLogicalSize;
	extern(C) int SDL_RenderSetLogicalSize(SDL_Renderer* renderer, int w, int h){ return _SDL_RenderSetLogicalSize(__traits(parameters)); }
	package _pSDL_RenderGetLogicalSize _SDL_RenderGetLogicalSize;
	extern(C) void SDL_RenderGetLogicalSize(SDL_Renderer* renderer, int* w, int* h){ _SDL_RenderGetLogicalSize(__traits(parameters)); }
	package _pSDL_RenderSetViewport _SDL_RenderSetViewport;
	extern(C) int SDL_RenderSetViewport(SDL_Renderer* renderer, const(SDL_Rect)* rect){ return _SDL_RenderSetViewport(__traits(parameters)); }
	package _pSDL_RenderGetViewport _SDL_RenderGetViewport;
	extern(C) void SDL_RenderGetViewport(SDL_Renderer* renderer, SDL_Rect* rect){ _SDL_RenderGetViewport(__traits(parameters)); }
	package _pSDL_RenderSetScale _SDL_RenderSetScale;
	extern(C) int SDL_RenderSetScale(SDL_Renderer* renderer, float scaleX, float scaleY){ return _SDL_RenderSetScale(__traits(parameters)); }
	package _pSDL_RenderGetScale _SDL_RenderGetScale;
	extern(C) int SDL_RenderGetScale(SDL_Renderer* renderer, float* scaleX, float* scaleY){ return _SDL_RenderGetScale(__traits(parameters)); }
	package _pSDL_SetRenderDrawColor _SDL_SetRenderDrawColor;
	extern(C) int SDL_SetRenderDrawColor(SDL_Renderer* renderer, ubyte r, ubyte g, ubyte b, ubyte a){ return _SDL_SetRenderDrawColor(__traits(parameters)); }
	package _pSDL_GetRenderDrawColor _SDL_GetRenderDrawColor;
	extern(C) int SDL_GetRenderDrawColor(SDL_Renderer* renderer, ubyte* r, ubyte* g, ubyte* b, ubyte* a){ return _SDL_GetRenderDrawColor(__traits(parameters)); }
	package _pSDL_SetRenderDrawBlendMode _SDL_SetRenderDrawBlendMode;
	extern(C) int SDL_SetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode blendMode){ return _SDL_SetRenderDrawBlendMode(__traits(parameters)); }
	package _pSDL_GetRenderDrawBlendMode _SDL_GetRenderDrawBlendMode;
	extern(C) int SDL_GetRenderDrawBlendMode(SDL_Renderer* renderer, SDL_BlendMode* blendMode){ return _SDL_GetRenderDrawBlendMode(__traits(parameters)); }
	package _pSDL_RenderClear _SDL_RenderClear;
	extern(C) int SDL_RenderClear(SDL_Renderer* renderer){ return _SDL_RenderClear(__traits(parameters)); }
	package _pSDL_RenderDrawPoint _SDL_RenderDrawPoint;
	extern(C) int SDL_RenderDrawPoint(SDL_Renderer* renderer, int x, int y){ return _SDL_RenderDrawPoint(__traits(parameters)); }
	package _pSDL_RenderDrawPoints _SDL_RenderDrawPoints;
	extern(C) int SDL_RenderDrawPoints(SDL_Renderer* renderer, const(SDL_Point)* points, int count){ return _SDL_RenderDrawPoints(__traits(parameters)); }
	package _pSDL_RenderDrawLine _SDL_RenderDrawLine;
	extern(C) int SDL_RenderDrawLine(SDL_Renderer* renderer, int x1, int y1, int x2, int y2){ return _SDL_RenderDrawLine(__traits(parameters)); }
	package _pSDL_RenderDrawLines _SDL_RenderDrawLines;
	extern(C) int SDL_RenderDrawLines(SDL_Renderer* renderer, const(SDL_Point)* points, int count){ return _SDL_RenderDrawLines(__traits(parameters)); }
	package _pSDL_RenderDrawRect _SDL_RenderDrawRect;
	extern(C) int SDL_RenderDrawRect(SDL_Renderer* renderer, const(SDL_Rect)* rect){ return _SDL_RenderDrawRect(__traits(parameters)); }
	package _pSDL_RenderDrawRects _SDL_RenderDrawRects;
	extern(C) int SDL_RenderDrawRects(SDL_Renderer* renderer, const(SDL_Rect)* rects, int count){ return _SDL_RenderDrawRects(__traits(parameters)); }
	package _pSDL_RenderFillRect _SDL_RenderFillRect;
	extern(C) int SDL_RenderFillRect(SDL_Renderer* renderer, const(SDL_Rect)* rect){ return _SDL_RenderFillRect(__traits(parameters)); }
	package _pSDL_RenderFillRects _SDL_RenderFillRects;
	extern(C) int SDL_RenderFillRects(SDL_Renderer* renderer, const(SDL_Rect)* rects, int count){ return _SDL_RenderFillRects(__traits(parameters)); }
	package _pSDL_RenderCopy _SDL_RenderCopy;
	extern(C) int SDL_RenderCopy(SDL_Renderer* renderer, SDL_Texture* texture, const(SDL_Rect)* srcRect, const(SDL_Rect)* dstRect){ return _SDL_RenderCopy(__traits(parameters)); }
	package _pSDL_RenderCopyEx _SDL_RenderCopyEx;
	extern(C) int SDL_RenderCopyEx(SDL_Renderer* renderer, SDL_Texture* texture, const(SDL_Rect)* srcRect, const(SDL_Rect)* dstRect, const(double) angle, const(SDL_Point)* centre, const(SDL_RendererFlip) flip){ return _SDL_RenderCopyEx(__traits(parameters)); }
	package _pSDL_RenderReadPixels _SDL_RenderReadPixels;
	extern(C) int SDL_RenderReadPixels(SDL_Renderer* renderer, const(SDL_Rect)* rect, uint, void*, int){ return _SDL_RenderReadPixels(__traits(parameters)); }
	package _pSDL_RenderPresent _SDL_RenderPresent;
	extern(C) void SDL_RenderPresent(SDL_Renderer* renderer){ _SDL_RenderPresent(__traits(parameters)); }
	package _pSDL_DestroyTexture _SDL_DestroyTexture;
	extern(C) void SDL_DestroyTexture(SDL_Texture* texture){ _SDL_DestroyTexture(__traits(parameters)); }
	package _pSDL_DestroyRenderer _SDL_DestroyRenderer;
	extern(C) void SDL_DestroyRenderer(SDL_Renderer* renderer){ _SDL_DestroyRenderer(__traits(parameters)); }
	package _pSDL_GL_BindTexture _SDL_GL_BindTexture;
	extern(C) int SDL_GL_BindTexture(SDL_Texture* texture, float* texw, float* texh){ return _SDL_GL_BindTexture(__traits(parameters)); }
	package _pSDL_GL_UnbindTexture _SDL_GL_UnbindTexture;
	extern(C) int SDL_GL_UnbindTexture(SDL_Texture* texture){ return _SDL_GL_UnbindTexture(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetNumRenderDrivers, here.SDL_GetNumRenderDrivers.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRenderDriverInfo, here.SDL_GetRenderDriverInfo.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateWindowAndRenderer, here.SDL_CreateWindowAndRenderer.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateRenderer, here.SDL_CreateRenderer.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateSoftwareRenderer, here.SDL_CreateSoftwareRenderer.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRenderer, here.SDL_GetRenderer.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRendererInfo, here.SDL_GetRendererInfo.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRendererOutputSize, here.SDL_GetRendererOutputSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateTexture, here.SDL_CreateTexture.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateTextureFromSurface, here.SDL_CreateTextureFromSurface.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_QueryTexture, here.SDL_QueryTexture.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetTextureColorMod, here.SDL_SetTextureColorMod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetTextureColorMod, here.SDL_GetTextureColorMod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetTextureAlphaMod, here.SDL_SetTextureAlphaMod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetTextureAlphaMod, here.SDL_GetTextureAlphaMod.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetTextureBlendMode, here.SDL_SetTextureBlendMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetTextureBlendMode, here.SDL_GetTextureBlendMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UpdateTexture, here.SDL_UpdateTexture.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_LockTexture, here.SDL_LockTexture.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_UnlockTexture, here.SDL_UnlockTexture.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderTargetSupported, here.SDL_RenderTargetSupported.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetRenderTarget, here.SDL_SetRenderTarget.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRenderTarget, here.SDL_GetRenderTarget.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderSetClipRect, here.SDL_RenderSetClipRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderGetClipRect, here.SDL_RenderGetClipRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderSetLogicalSize, here.SDL_RenderSetLogicalSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderGetLogicalSize, here.SDL_RenderGetLogicalSize.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderSetViewport, here.SDL_RenderSetViewport.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderGetViewport, here.SDL_RenderGetViewport.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderSetScale, here.SDL_RenderSetScale.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderGetScale, here.SDL_RenderGetScale.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetRenderDrawColor, here.SDL_SetRenderDrawColor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRenderDrawColor, here.SDL_GetRenderDrawColor.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetRenderDrawBlendMode, here.SDL_SetRenderDrawBlendMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRenderDrawBlendMode, here.SDL_GetRenderDrawBlendMode.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderClear, here.SDL_RenderClear.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderDrawPoint, here.SDL_RenderDrawPoint.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderDrawPoints, here.SDL_RenderDrawPoints.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderDrawLine, here.SDL_RenderDrawLine.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderDrawLines, here.SDL_RenderDrawLines.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderDrawRect, here.SDL_RenderDrawRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderDrawRects, here.SDL_RenderDrawRects.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderFillRect, here.SDL_RenderFillRect.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderFillRects, here.SDL_RenderFillRects.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderCopy, here.SDL_RenderCopy.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderCopyEx, here.SDL_RenderCopyEx.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderReadPixels, here.SDL_RenderReadPixels.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RenderPresent, here.SDL_RenderPresent.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DestroyTexture, here.SDL_DestroyTexture.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_DestroyRenderer, here.SDL_DestroyRenderer.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_BindTexture, here.SDL_GL_BindTexture.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GL_UnbindTexture, here.SDL_GL_UnbindTexture.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/shape.d(50,1)
private nothrow @nogc{
	alias _pSDL_CreateShapedWindow = extern(C) SDL_Window* function(const(char)* title, uint x, uint y, uint w, uint h, SDL_WindowFlags flags);
	alias _pSDL_IsShapedWindow = extern(C) SDL_bool function(const(SDL_Window)* window);
	alias _pSDL_SetWindowShape = extern(C) int function(SDL_Window* window, SDL_Surface* shape, SDL_WindowShapeMode* shapeMode);
	alias _pSDL_GetShapedWindowMode = extern(C) int function(SDL_Window* window, SDL_WindowShapeMode* shapeMode);
}
__gshared nothrow @nogc{
	package _pSDL_CreateShapedWindow _SDL_CreateShapedWindow;
	extern(C) SDL_Window* SDL_CreateShapedWindow(const(char)* title, uint x, uint y, uint w, uint h, SDL_WindowFlags flags){ return _SDL_CreateShapedWindow(__traits(parameters)); }
	package _pSDL_IsShapedWindow _SDL_IsShapedWindow;
	extern(C) SDL_bool SDL_IsShapedWindow(const(SDL_Window)* window){ return _SDL_IsShapedWindow(__traits(parameters)); }
	package _pSDL_SetWindowShape _SDL_SetWindowShape;
	extern(C) int SDL_SetWindowShape(SDL_Window* window, SDL_Surface* shape, SDL_WindowShapeMode* shapeMode){ return _SDL_SetWindowShape(__traits(parameters)); }
	package _pSDL_GetShapedWindowMode _SDL_GetShapedWindowMode;
	extern(C) int SDL_GetShapedWindowMode(SDL_Window* window, SDL_WindowShapeMode* shapeMode){ return _SDL_GetShapedWindowMode(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_CreateShapedWindow, here.SDL_CreateShapedWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_IsShapedWindow, here.SDL_IsShapedWindow.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetWindowShape, here.SDL_SetWindowShape.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetShapedWindowMode, here.SDL_GetShapedWindowMode.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/system.d(66,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/thread.d(88,1)
private nothrow @nogc{
	alias _pSDL_GetThreadName = extern(C) const(char)* function(SDL_Thread* thread);
	alias _pSDL_ThreadID = extern(C) SDL_threadID function();
	alias _pSDL_GetThreadID = extern(C) SDL_threadID function(SDL_Thread* thread);
	alias _pSDL_SetThreadPriority = extern(C) int function(SDL_ThreadPriority priority);
	alias _pSDL_WaitThread = extern(C) void function(SDL_Thread* thread, int* status);
	alias _pSDL_TLSCreate = extern(C) SDL_TLSID function();
	alias _pSDL_TLSGet = extern(C) void* function(SDL_TLSID id);
	alias _pSDL_TLSSet = extern(C) int function(SDL_TLSID id, const(void)* value, TLSDestructor destructor);
	alias _pSDL_CreateThread = extern(C) SDL_Thread* function(SDL_ThreadFunction fn, const(char)* name, void* data);
}
__gshared nothrow @nogc{
	package _pSDL_GetThreadName _SDL_GetThreadName;
	extern(C) const(char)* SDL_GetThreadName(SDL_Thread* thread){ return _SDL_GetThreadName(__traits(parameters)); }
	package _pSDL_ThreadID _SDL_ThreadID;
	extern(C) SDL_threadID SDL_ThreadID(){ return _SDL_ThreadID(__traits(parameters)); }
	package _pSDL_GetThreadID _SDL_GetThreadID;
	extern(C) SDL_threadID SDL_GetThreadID(SDL_Thread* thread){ return _SDL_GetThreadID(__traits(parameters)); }
	package _pSDL_SetThreadPriority _SDL_SetThreadPriority;
	extern(C) int SDL_SetThreadPriority(SDL_ThreadPriority priority){ return _SDL_SetThreadPriority(__traits(parameters)); }
	package _pSDL_WaitThread _SDL_WaitThread;
	extern(C) void SDL_WaitThread(SDL_Thread* thread, int* status){ _SDL_WaitThread(__traits(parameters)); }
	package _pSDL_TLSCreate _SDL_TLSCreate;
	extern(C) SDL_TLSID SDL_TLSCreate(){ return _SDL_TLSCreate(__traits(parameters)); }
	package _pSDL_TLSGet _SDL_TLSGet;
	extern(C) void* SDL_TLSGet(SDL_TLSID id){ return _SDL_TLSGet(__traits(parameters)); }
	package _pSDL_TLSSet _SDL_TLSSet;
	extern(C) int SDL_TLSSet(SDL_TLSID id, const(void)* value, TLSDestructor destructor){ return _SDL_TLSSet(__traits(parameters)); }
	package _pSDL_CreateThread _SDL_CreateThread;
	extern(C) SDL_Thread* SDL_CreateThread(SDL_ThreadFunction fn, const(char)* name, void* data){ return _SDL_CreateThread(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetThreadName, here.SDL_GetThreadName.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_ThreadID, here.SDL_ThreadID.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetThreadID, here.SDL_GetThreadID.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_SetThreadPriority, here.SDL_SetThreadPriority.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WaitThread, here.SDL_WaitThread.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_TLSCreate, here.SDL_TLSCreate.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_TLSGet, here.SDL_TLSGet.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_TLSSet, here.SDL_TLSSet.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_CreateThread, here.SDL_CreateThread.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/timer.d(22,1)
private nothrow @nogc{
	alias _pSDL_GetTicks = extern(C) uint function();
	alias _pSDL_GetPerformanceCounter = extern(C) ulong function();
	alias _pSDL_GetPerformanceFrequency = extern(C) ulong function();
	alias _pSDL_Delay = extern(C) void function(uint ms);
	alias _pSDL_AddTimer = extern(C) SDL_TimerID function(uint interval, SDL_TimerCallback callback, void* param);
	alias _pSDL_RemoveTimer = extern(C) SDL_bool function(SDL_TimerID id);
}
__gshared nothrow @nogc{
	package _pSDL_GetTicks _SDL_GetTicks;
	extern(C) uint SDL_GetTicks(){ return _SDL_GetTicks(__traits(parameters)); }
	package _pSDL_GetPerformanceCounter _SDL_GetPerformanceCounter;
	extern(C) ulong SDL_GetPerformanceCounter(){ return _SDL_GetPerformanceCounter(__traits(parameters)); }
	package _pSDL_GetPerformanceFrequency _SDL_GetPerformanceFrequency;
	extern(C) ulong SDL_GetPerformanceFrequency(){ return _SDL_GetPerformanceFrequency(__traits(parameters)); }
	package _pSDL_Delay _SDL_Delay;
	extern(C) void SDL_Delay(uint ms){ _SDL_Delay(__traits(parameters)); }
	package _pSDL_AddTimer _SDL_AddTimer;
	extern(C) SDL_TimerID SDL_AddTimer(uint interval, SDL_TimerCallback callback, void* param){ return _SDL_AddTimer(__traits(parameters)); }
	package _pSDL_RemoveTimer _SDL_RemoveTimer;
	extern(C) SDL_bool SDL_RemoveTimer(SDL_TimerID id){ return _SDL_RemoveTimer(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetTicks, here.SDL_GetTicks.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetPerformanceCounter, here.SDL_GetPerformanceCounter.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetPerformanceFrequency, here.SDL_GetPerformanceFrequency.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_Delay, here.SDL_Delay.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_AddTimer, here.SDL_AddTimer.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_RemoveTimer, here.SDL_RemoveTimer.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/version_.d(36,1)
private nothrow @nogc{
	alias _pSDL_GetVersion = extern(C) void function(SDL_version* ver);
	alias _pSDL_GetRevision = extern(C) const(char)* function();
	alias _pSDL_GetRevisionNumber = extern(C) int function();
}
__gshared nothrow @nogc{
	package _pSDL_GetVersion _SDL_GetVersion;
	extern(C) void SDL_GetVersion(SDL_version* ver){ _SDL_GetVersion(__traits(parameters)); }
	package _pSDL_GetRevision _SDL_GetRevision;
	extern(C) const(char)* SDL_GetRevision(){ return _SDL_GetRevision(__traits(parameters)); }
	package _pSDL_GetRevisionNumber _SDL_GetRevisionNumber;
	extern(C) int SDL_GetRevisionNumber(){ return _SDL_GetRevisionNumber(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_GetVersion, here.SDL_GetVersion.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRevision, here.SDL_GetRevision.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_GetRevisionNumber, here.SDL_GetRevisionNumber.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/vulkan.d(16,1)
private nothrow @nogc{
}
__gshared nothrow @nogc{
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/package.d(89,1)
private nothrow @nogc{
	alias _pSDL_Init = extern(C) int function(uint flags);
	alias _pSDL_InitSubSystem = extern(C) int function(uint flags);
	alias _pSDL_QuitSubSystem = extern(C) void function(uint flags);
	alias _pSDL_WasInit = extern(C) uint function(uint flags);
	alias _pSDL_Quit = extern(C) void function();
}
__gshared nothrow @nogc{
	package _pSDL_Init _SDL_Init;
	extern(C) int SDL_Init(uint flags){ return _SDL_Init(__traits(parameters)); }
	package _pSDL_InitSubSystem _SDL_InitSubSystem;
	extern(C) int SDL_InitSubSystem(uint flags){ return _SDL_InitSubSystem(__traits(parameters)); }
	package _pSDL_QuitSubSystem _SDL_QuitSubSystem;
	extern(C) void SDL_QuitSubSystem(uint flags){ _SDL_QuitSubSystem(__traits(parameters)); }
	package _pSDL_WasInit _SDL_WasInit;
	extern(C) uint SDL_WasInit(uint flags){ return _SDL_WasInit(__traits(parameters)); }
	package _pSDL_Quit _SDL_Quit;
	extern(C) void SDL_Quit(){ _SDL_Quit(__traits(parameters)); }
}

import bindbc.loader: SharedLib, bindSymbol;
static void bindModuleSymbols(SharedLib lib) nothrow @nogc{
	alias here = mixin((string mod=__MODULE__){
	static if(__traits(compiles, typeof(this))) return __traits(identifier, typeof(this));
	else return mod;
}());
	lib.bindSymbol(cast(void**)&_SDL_Init, here.SDL_Init.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_InitSubSystem, here.SDL_InitSubSystem.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_QuitSubSystem, here.SDL_QuitSubSystem.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_WasInit, here.SDL_WasInit.mangleof);
	lib.bindSymbol(cast(void**)&_SDL_Quit, here.SDL_Quit.mangleof);
}

// expansion at ../../../../.dub/packages/bindbc-sdl/1.5.1/bindbc-sdl/source/sdl/package.d(133,1)

void unloadSDL(){ if(lib != invalidHandle) lib.unload(); }

bool isSDLLoaded(){ return lib != invalidHandle; }

SDLSupport loadSDL(){
	const(char)[][libNamesCT.length] libNames = libNamesCT;

	SDLSupport ret;
	foreach(name; libNames){
		ret = loadSDL(name.ptr);
		//TODO: keep trying until we get the version we want, otherwise default to the highest one?
		if(ret != SDLSupport.noLibrary && ret != SDLSupport.badLibrary) break;
	}
	return ret;
}

SDLSupport loadSDL(const(char)* libName){
	lib = bindbc.loader.load(libName);
	if(lib == invalidHandle){
		return SDLSupport.noLibrary;
	}

	auto errCount = errorCount();
	loadedVersion = SDLSupport.badLibrary;

	sdl.bindModuleSymbols(lib);
	sdl.assert_.bindModuleSymbols(lib);
	sdl.atomic.bindModuleSymbols(lib);
	sdl.audio.bindModuleSymbols(lib);
	sdl.blendmode.bindModuleSymbols(lib);
	sdl.clipboard.bindModuleSymbols(lib);
	sdl.cpuinfo.bindModuleSymbols(lib);
	sdl.error.bindModuleSymbols(lib);
	sdl.events.bindModuleSymbols(lib);
	sdl.filesystem.bindModuleSymbols(lib);
	sdl.gamecontroller.bindModuleSymbols(lib);
	sdl.gesture.bindModuleSymbols(lib);
	sdl.guid.bindModuleSymbols(lib);
	sdl.haptic.bindModuleSymbols(lib);
	sdl.hidapi.bindModuleSymbols(lib);
	sdl.hints.bindModuleSymbols(lib);
	sdl.joystick.bindModuleSymbols(lib);
	sdl.keyboard.bindModuleSymbols(lib);
	sdl.loadso.bindModuleSymbols(lib);
	sdl.locale.bindModuleSymbols(lib);
	sdl.log.bindModuleSymbols(lib);
	sdl.messagebox.bindModuleSymbols(lib);
	sdl.metal.bindModuleSymbols(lib);
	sdl.misc.bindModuleSymbols(lib);
	sdl.mouse.bindModuleSymbols(lib);
	sdl.mutex.bindModuleSymbols(lib);
	sdl.pixels.bindModuleSymbols(lib);
	sdl.platform.bindModuleSymbols(lib);
	sdl.power.bindModuleSymbols(lib);
	sdl.rect.bindModuleSymbols(lib);
	sdl.render.bindModuleSymbols(lib);
	sdl.rwops.bindModuleSymbols(lib);
	sdl.sensor.bindModuleSymbols(lib);
	sdl.shape.bindModuleSymbols(lib);
	sdl.stdinc.bindModuleSymbols(lib);
	sdl.surface.bindModuleSymbols(lib);
	sdl.system.bindModuleSymbols(lib);
	sdl.syswm.bindModuleSymbols(lib);
	sdl.thread.bindModuleSymbols(lib);
	sdl.timer.bindModuleSymbols(lib);
	sdl.touch.bindModuleSymbols(lib);
	sdl.version_.bindModuleSymbols(lib);
	sdl.video.bindModuleSymbols(lib);
	sdl.vulkan.bindModuleSymbols(lib);

	if(errCount == errorCount()) loadedVersion = sdlSupport; //this is a white-lie in order to maintain backwards-compatibility :(
	return loadedVersion;
}

// expansion at /Library/D/dmd/src/phobos/std/functional.d(452,16)
cast(T)a < cast(T) b

// expansion at /Library/D/dmd/src/phobos/std/internal/memory.d(32,18)
onOutOfMemoryError();

// expansion at /Library/D/dmd/src/phobos/std/internal/memory.d(40,18)
onOutOfMemoryError();

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(222,13)
alias a = __a ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(223,13)
alias b = __b ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(224,20)
a == b

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(222,13)
alias a = __a ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(223,13)
alias b = __b ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(224,20)
a == b

// expansion at /Library/D/dmd/src/phobos/std/functional.d(222,13)
alias a = __a ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(223,13)
alias b = __b ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(224,20)
a == b

// expansion at /Library/D/dmd/src/phobos/std/functional.d(452,16)
cast(T)a < cast(T) b

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(467,13)
enum int data = 0;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(467,13)
enum int count = 0;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(654,9)
alias _0LU = Identity!(field[0LU]);alias data = _0LU;alias _1LU = Identity!(field[1LU]);alias count = _1LU;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(654,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /Library/D/dmd/src/phobos/std/format/spec.d(170,13)
private ubyte _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf;@property bool flDash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 1U) != 0;}
@property void flDash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 1U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))1U);}
@property bool flZero() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 2U) != 0;}
@property void flZero(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 2U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))2U);}
@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}
@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}
@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}
@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}
@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}
@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}
@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}
@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}
@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}
@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(467,13)
enum int schema = 0;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(467,13)
enum int sequence = 0;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(654,9)
alias _0LU = Identity!(field[0LU]);alias schema = _0LU;alias _1LU = Identity!(field[1LU]);alias sequence = _1LU;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(654,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/functional.d(222,13)
alias a = __a ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(223,13)
alias b = __b ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(224,20)
a == b

// expansion at /Library/D/dmd/src/phobos/std/functional.d(222,13)
alias a = __a ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(223,13)
alias b = __b ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(224,20)
a == b

// expansion at /Library/D/dmd/src/phobos/std/functional.d(222,13)
alias a = __a ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(223,13)
alias b = __b ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(224,20)
a == b

// expansion at /Library/D/dmd/src/phobos/std/functional.d(222,13)
alias a = __a ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(223,13)
alias b = __b ;

// expansion at /Library/D/dmd/src/phobos/std/functional.d(224,20)
a == b

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(654,9)
alias _0LU = Identity!(field[0LU]);alias _1LU = Identity!(field[1LU]);alias _2LU = Identity!(field[2LU]);

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/geometry/surface.d(21,9)
ulong[3LU] offsets;

// expansion at source/geometry/surface.d(22,9)
offsets[0] = 0;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(0LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(0LU, 3LU, GL_FLOAT, GL_FALSE, 32LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(29,17)
offsets[1LU] = offsets[0LU] + 3LU;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(1LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(1LU, 3LU, GL_FLOAT, GL_FALSE, 32LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(29,17)
offsets[2LU] = offsets[1LU] + 3LU;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(2LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(2LU, 2LU, GL_FLOAT, GL_FALSE, 32LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(0LU);

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(1LU);

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(2LU);

// expansion at source/geometry/surface.d(21,9)
ulong[2LU] offsets;

// expansion at source/geometry/surface.d(22,9)
offsets[0] = 0;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(0LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(0LU, 3LU, GL_FLOAT, GL_FALSE, 24LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(29,17)
offsets[1LU] = offsets[0LU] + 3LU;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(1LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(1LU, 3LU, GL_FLOAT, GL_FALSE, 24LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(0LU);

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(1LU);

// expansion at source/geometry/surface.d(21,9)
ulong[2LU] offsets;

// expansion at source/geometry/surface.d(22,9)
offsets[0] = 0;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(0LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(0LU, 3LU, GL_FLOAT, GL_FALSE, 20LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(29,17)
offsets[1LU] = offsets[0LU] + 3LU;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(1LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(1LU, 2LU, GL_FLOAT, GL_FALSE, 20LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(0LU);

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(1LU);

// expansion at source/geometry/surface.d(21,9)
ulong[5LU] offsets;

// expansion at source/geometry/surface.d(22,9)
offsets[0] = 0;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(0LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(0LU, 3LU, GL_FLOAT, GL_FALSE, 56LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(29,17)
offsets[1LU] = offsets[0LU] + 3LU;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(1LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(1LU, 2LU, GL_FLOAT, GL_FALSE, 56LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(29,17)
offsets[2LU] = offsets[1LU] + 2LU;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(2LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(2LU, 3LU, GL_FLOAT, GL_FALSE, 56LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(29,17)
offsets[3LU] = offsets[2LU] + 3LU;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(3LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(3LU, 3LU, GL_FLOAT, GL_FALSE, 56LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at source/geometry/surface.d(29,17)
offsets[4LU] = offsets[3LU] + 3LU;

// expansion at source/geometry/surface.d(26,13)
glEnableVertexAttribArray(4LU);

// expansion at source/geometry/surface.d(27,13)
glVertexAttribPointer(4LU, 3LU, GL_FLOAT, GL_FALSE, 56LU, cast(GLvoid*)(GLfloat.sizeof*offsets[idx]));

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(0LU);

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(1LU);

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(2LU);

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(3LU);

// expansion at source/geometry/surface.d(39,13)
glDisableVertexAttribArray(4LU);

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at /Library/D/dmd/src/druntime/import/core/internal/atomic.d(138,13)

                asm pure nothrow @nogc @trusted
                {
                    push RBX; // call preserved

                    mov EDX, 0;
                    mov EAX, 0;
                    mov RCX, src;
                    lock; cmpxchg [RCX], EDX;
                    lea RBX, resultValuePtr;
                    mov RBX, [RBX];
                    mov [RBX], EAX;

                    pop RBX;
                }


// expansion at /Library/D/dmd/src/druntime/import/core/atomic.d(542,9)
*cast(T*)&val+=mod

// expansion at /Library/D/dmd/src/druntime/import/core/internal/atomic.d(264,13)

                asm pure nothrow @nogc @trusted
                {
                    naked;
                    lock; xadd[RSI], EDI;
                    mov EAX, EDI;
                    ret;
                }


// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs == rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at /Library/D/dmd/src/phobos/std/typecons.d(539,31)
lhs < rhs

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

// expansion at
.object.size_t h = 0;foreach (i, T; typeof(p.tupleof))    static if(is(T* : const(.object.Object)*))         h = h * 33 + typeid(const(.object.Object)).getHash(cast(const void*)&p.tupleof[i]);    else         h = h * 33 + typeid(T).getHash(cast(const void*)&p.tupleof[i]);return h;

